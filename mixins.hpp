#pragma once

#ifndef __cplusplus
#error "C++ is required.";
#endif // ! __cplusplus

#ifndef _HAS_CXX23
#pragma message("C++ 23 not detected, some features of C++ 23 will be available in Mixins as soon as possible.")
#endif

// Heckerpowered.Mixins service and template library.
// Copyright (c) Heckerpowered Corporation.
#pragma message("Heckerpowered.Mixins v1.0.1.22528 build.")

#pragma optimize("t", on) // Specify fast sequences of machine code.

#ifdef __mixins_development
#define __mixin_export __declspec(dllexport)
#else
#pragma system_header
#define __mixin_export __declspec(dllimport)
#endif

#ifdef UNICODE
#pragma message("Mixin does not fully support Unicode, which may make some features unavailable.")
#endif // UNICODE

#include <Windows.h>

namespace mixins
{
	/// <summary>
	/// Process guarding level provided by "Mixins" service.
	/// <para>When a guard is applied to the specified process, all the guards of lower level than it also take effect.</para>
	/// <para>For example, when you apply a protection of "highest" level on the specified process, </para>
	/// <para>the protection of "strict" level and "basic" level also takes effect.</para>
	/// </summary>
	enum class guard_level
	{
		/// <summary>
		/// Disable any guards applied to the specified process.
		/// </summary>
		disabled,

		/// <summary>
		/// <para>Enable minimal safeguards on the specified process, affecting but not limited to the following actions:</para>
		/// <para>　</para>
		/// <para>1. Make the handle lose any privileges when the handle is opened/created.</para>
		/// <para>2. Hide guarded processes in the process list.</para>
		/// <para>3. Disable some SSDT functions.</para>
		/// <para>　</para>
		/// This safeguard may prevent process creation and it is recommended to enable this level of protection as soon as the process has been created.
		/// </summary>
		basic,

		/// <summary>
		/// <para>This guard may prevent the process from loading, it is recommended to enable this level of guard after the process has finished loading.</para>
		/// <para>　</para>
		/// <para>Compared to the "basic" level of guard, enabling the "strict" level of guard disables the following actions:</para>
		/// <para>1. Allocate code pages.</para>
		/// <para>2. Change the properties of the code page to writable or change the properties of the normal page to executable.</para>
		/// <para>3. Load dlls without Microsoft signature</para>
		/// <para>4. Create remote threads and block all access from the user.</para>
		/// <para>　</para>
		/// <para>Some of these operations may not work on lower versions of the operating system.</para>
		/// </summary>
		strict,

		/// <summary>
		/// <para>This level of guard may affect the normal working of the process,</para>
		/// <para>so it is recommended not to enable this level of guard for too long.</para>
		/// <para>Compared to the "strict" level of guard, enabling the "highest" level of guard disables the following actions:</para>
		/// <para>1. Create threads.</para>
		/// <para>2. Load any dll.</para>
		/// <para>3. All SSDT functions.</para>
		/// <para>4. All user-mode APC delivery to any threads of guarded process.</para>
		/// </summary>
		highest,
	};

	/// <summary>
	/// <para>Initialize the Mixins service.</para>
	/// This function needs to be called before you can use any of the functions provided by the "Mixins" service.
	/// </summary>
	/// <returns>If the function succeeds, the return value is true.</returns>
	extern "C" __mixin_export bool init_service() noexcept;

	/// <summary>
	/// <para>Raise or lower the guard level of this process.</para>
	/// The guard level must be the value in the enumeration "guard_level".
	/// </summary>
	/// <param name="guard_level">Level of guard to be raising or lowering to.</param>
	/// <param name="process_id">Process Id for raising or lowering the guard level.</param>
	/// <returns>If the function succeeds, the return value is true.</returns>
	extern "C" __mixin_export bool raise_process_guard_level(guard_level level, unsigned __int64 process_id = GetCurrentProcessId()) noexcept;

	/// <summary>
	/// Forces termination of the underlying process.
	/// </summary>
	/// <returns>If the function succeeds, the return value is true.</returns>
	extern "C" __mixin_export bool terminate_process(unsigned __int64 process_id) noexcept;
}

// Mixins template library (mtl)
#ifndef __disable_mixin_template_library

#include <wow64apiset.h>
#include <winternl.h>
#include <TlHelp32.h>
#include <intrin.h>
#include <CommCtrl.h>

#include <cstddef>
#include <algorithm>
#include <charconv>
#include <array>
#include <atomic>
#include <string>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <deque>
#include <queue>
#include <map>
#include <set>
#include <concepts>
#include <optional>
#include <numeric>
#include <coroutine>
#include <memory>
#include <utility>
#include <thread>
#include <chrono>
#include <fstream>
#include <thread>
#include <tuple>
#include <type_traits>
#include <limits>
#include <filesystem> // <- Security vulnerability.

using namespace std::chrono_literals;

#if __has_cpp_attribute(gnu::always_inline)
#define __mixin_forceinline [[gnu::always_inline]]
#else // __has_cpp_attribute(msvc::forceinline)

// The attribute "msvc::forceinline" is correctly recognized by the
// compiler, but the macro "__has_cpp_attribute" does not
// necessarily recognize this attribute.
#define __mixin_forceinline [[msvc::forceinline]]
#endif

//
// Encrypt any strings used in mixin and decrypt them at runtime,
// which may cause extra expenses and does not leave any strings in memory.
//
#ifdef __mixin_encrypt_string__
#define __mixin_xor_string(x) __xor_string(x)
#else
#define __mixin_xor_string(x) x
#endif

#undef max
#undef min

#ifdef __mixin_link_comctl32__
#pragma comment(lib, "Comctl32.lib")
#pragma comment(linker, "/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='amd64' publicKeyToken='6595b64144ccf1df' language='*'\"")
#endif // __mixin_link_comctl32__

namespace mixins
{
	#ifdef UNICODE
	using char_type = wchar_t;
	#else
	using char_type = char;
	#endif

	template <typename char_type>
	concept character = std::is_same_v<char_type, char> || std::is_same_v<char_type, wchar_t>;

	template<typename T> concept iec559 = std::numeric_limits<T>::is_iec559;
	template<typename T> concept boolean = std::is_same_v<bool, std::decay_t<T>>;
	template<typename T> concept pointer = std::is_pointer_v<T>;

	template<typename T> concept not_boolean = !boolean<T>;

	template<typename T> concept operator_and = requires{ std::declval<T>()& std::declval<T>(); };
	template<typename T> concept operator_logical_and = requires{ std::declval<T>() && std::declval<T>(); };
	template<typename T> concept operator_inclusive_or = requires{ std::declval<T>() | std::declval<T>(); };
	template<typename T> concept operator_exclusive_or = requires{ std::declval<T>() ^ std::declval<T>(); };
	template<typename T> concept operator_negation = requires{ !std::declval<T>(); };
	template<typename T> concept operator_plus = requires{ std::declval<T>() + std::declval<T>(); };

	template<typename T> concept nullable = requires{ std::declval<T>() != nullptr; };
	template<typename T> concept not_nullable = !nullable<T>;

	template<typename T> concept string = std::is_same_v<T, std::string> || std::is_same_v<T, std::wstring> || std::is_same_v<T, std::string_view> || std::is_same_v<T, std::wstring_view>;

	template<typename T> concept not_string = !string<T>;

	template<typename T>
	using decay_t = std::remove_volatile_t<std::remove_const_t<std::remove_reference_t<std::remove_pointer_t<std::remove_all_extents_t<std::decay_t<T>>>>>>;

	template<typename T>
	using char_type_t = std::conditional_t<std::_Is_any_of_v<decay_t<T>, char, std::string, std::string_view>, char,
		std::conditional_t<std::_Is_any_of_v<decay_t<T>, wchar_t, std::wstring, std::wstring_view>, wchar_t, void>>;

	template <typename container_t>
	concept container = requires(container_t a, container_t const b)
	{
		requires std::regular<container_t>;
		requires std::swappable<container_t>;
		requires std::destructible<typename container_t::value_type>;
		requires std::same_as<typename container_t::reference, typename container_t::value_type&>;
		requires std::same_as<typename container_t::const_reference, typename container_t::value_type const&>;
		requires std::forward_iterator<typename container_t::iterator>;
		requires std::forward_iterator<typename container_t::const_iterator>;
		requires std::signed_integral<typename container_t::difference_type>;
		requires std::same_as<typename container_t::difference_type, typename std::iterator_traits<typename container_t::iterator>::difference_type>;
		requires std::same_as<typename container_t::difference_type, typename std::iterator_traits<typename container_t::const_iterator>::difference_type>;
		requires std::same_as<decltype(a.begin()), typename container_t::iterator>;
		requires std::same_as<decltype(a.end()), typename container_t::iterator>;
		requires std::same_as<decltype(b.begin()), typename container_t::const_iterator>;
		requires std::same_as<decltype(b.end()), typename container_t::const_iterator>;
		requires std::same_as<decltype(a.cbegin()), typename container_t::const_iterator>;
		requires std::same_as<decltype(a.cend()), typename container_t::const_iterator>;
		requires std::same_as<decltype(a.size()), typename container_t::size_type>;
		requires std::same_as<decltype(a.max_size()), typename container_t::size_type>;
		requires std::same_as<decltype(a.empty()), bool>;
	};

	template<typename T, typename U> concept reinterpret_castable = requires(T && t, U && u)
	{
		requires reinterpret_cast<T&&>(u);
	};

	template<typename T, typename U> concept static_castable = requires(T && t, U && u)
	{
		requires static_cast<T&&>(u);
	};

	constexpr void ensure(bool condition)
	{
		if (!condition) { std::terminate(); };
	}

	using index = std::ptrdiff_t;

	template<nullable T>
	class not_null
	{
	public:
		template<typename U, typename = std::enable_if_t<std::is_convertible<U, T>::value>>
		constexpr not_null(U&& u) : _pointer(std::forward<U>(u))
		{
			ensure(_pointer != nullptr);
		}

		template <typename = std::enable_if_t<!std::is_same<std::nullptr_t, T>::value>>
		constexpr not_null(T u) : _pointer(std::move(u))
		{
			ensure(_pointer != nullptr);
		}

		template <typename U, typename = std::enable_if_t<std::is_convertible<U, T>::value>>
		constexpr not_null(const not_null<U>& other) : not_null(other.get())
		{
		}

		not_null(not_null const& other) = default;
		not_null& operator=(not_null const& other) = default;

		constexpr std::conditional_t<std::is_copy_constructible<T>::value, T, T const&> get() const
		{
			ensure(_pointer != nullptr);
			return _pointer;
		}

		constexpr operator T() const { return get(); }
		constexpr decltype(auto) operator->() const { return get(); }
		constexpr decltype(auto) operator*() const { return *get(); }

		not_null(std::nullptr_t) = delete;
		not_null& operator=(std::nullptr_t) = delete;

		not_null& operator++() = delete;
		not_null& operator--() = delete;
		not_null operator++(int) = delete;
		not_null operator--(int) = delete;
		not_null& operator+=(std::ptrdiff_t) = delete;
		not_null& operator-=(std::ptrdiff_t) = delete;
		void operator[](std::ptrdiff_t) const = delete;
	private:
		T _pointer;
	};

	template<typename T>
	using not_null_t = std::conditional_t<nullable<T>, not_null<T>, T>;

	template <typename T>
	constexpr auto make_not_null(T&& t) noexcept
	{
		return not_null<std::remove_cv_t<std::remove_reference_t<T>>>{std::forward<T>(t)};
	}

	/// <summary>
	/// Gets the calling thread's last-error code value and format this error code into a message string.
	/// <para/>
	/// You can specify an error code instead of last-error
	/// </summary>
	/// <param name="code">Error code</param>
	/// <returns>
	/// If the function succeeds, the return value is the formatted message string.
	/// <para/>
	/// If the function fails, the return value is a empty string.
	/// </returns>
	template <character char_type = typename mixins::char_type>
	__mixin_forceinline inline std::basic_string<char_type> last_error(unsigned long code = GetLastError()) noexcept
	{
		//
		// This should be impossible, "char_type" is either char or wchar_t.
		//
		static_assert(std::is_same_v<char_type, char> || std::is_same_v<char_type, wchar_t>, "Unsupported char type.");
	}

	/// <summary>
	/// Gets the calling thread's last-error code value and format this error code into a message string.
	/// <para/>
	/// You can specify an error code instead of last-error
	/// </summary>
	/// <param name="code">Error code</param>
	/// <returns>
	/// If the function succeeds, the return value is the formatted message string.
	/// <para/>
	/// If the function fails, the return value is a empty string.
	/// </returns>
	template <>
	__mixin_forceinline inline std::string last_error<char>(unsigned long code) noexcept
	{
		char* buffer{};
		auto size{ FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, nullptr, code,
								 MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), reinterpret_cast<char*>(&buffer), 0, nullptr) };

		char const* back{ buffer + size - 1 };
		while (size && std::isspace(*back))
		{
			--size;
			--back;
		}

		std::string message{ buffer, size };
		LocalFree(buffer);
		return message;
	}

	/// <summary>
	/// Gets the calling thread's last-error code value and format this error code into a message string.
	/// <para/>
	/// You can specify an error code instead of last-error
	/// </summary>
	/// <param name="code">Error code</param>
	/// <returns>
	/// If the function succeeds, the return value is the formatted message string.
	/// <para/>
	/// If the function fails, the return value is a empty string.
	/// </returns>
	template <>
	__mixin_forceinline inline std::wstring last_error<wchar_t>(unsigned long code) noexcept
	{
		wchar_t* buffer{};
		auto size{ FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, nullptr, code,
								 MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), reinterpret_cast<wchar_t*>(&buffer), 0, nullptr) };

		wchar_t const* back{ buffer + size - 1 };
		while (size && iswspace(*back))
		{
			--size;
			--back;
		}

		std::wstring message{ buffer, size };
		LocalFree(buffer);
		return message;
	}

	template <typename T>
	struct non_zero
	{
		__mixin_forceinline static inline bool call(T handle) noexcept { return std::int64_t(handle) != 0; }
	};

	template <typename T>
	struct non_negative
	{
		__mixin_forceinline static inline bool call(T handle) noexcept { return std::int64_t(handle) > 0; }
	};

	template <template <typename> typename wrapped_t, typename T>
	struct with_pseudo_t
	{
		static bool call(T handle) noexcept
		{
			if (wrapped_t<T>::call(handle))
			{
				return true;
			}

			//
			// Check if it's a pseudo handle.
			//

			auto h{ reinterpret_cast<HANDLE>(reinterpret_cast<std::uintptr_t>(handle)) };
			return h == GetCurrentProcess() || h == GetCurrentThread();
		}
	};

	template <template <typename> typename wrapped_t>
	struct with_pseudo
	{
		template <typename T>
		using type = with_pseudo_t<wrapped_t, T>;
	};

	/// <summary>
	/// Manages the storage of a handle, and automatically delete the handle they manage.
	/// </summary>
	/// <typeparam name="handle_t">The type of the handle, usually "HANDLE".</typeparam>
	/// <typeparam name="close_handler">Handle deleter, usually "CloseHandle"</typeparam>
	template <typename handle_t, auto close_handler, template <typename> typename is_valid = non_negative>
	class unique_handle
	{
	private:
		handle_t _handle;

	public:
		static constexpr handle_t invalid_handle_value = handle_t(0);

		unique_handle(const unique_handle&) = delete;
		unique_handle& operator=(unique_handle const&) = delete;

		__mixin_forceinline inline explicit unique_handle(handle_t handle = invalid_handle_value) noexcept : _handle(handle) {}
		__mixin_forceinline inline unique_handle(unique_handle&& other) noexcept : _handle(other._handle) { other._handle = invalid_handle_value; }

		__mixin_forceinline inline ~unique_handle()
		{
			if (is_valid<handle_t>::call(_handle))
			{
				close_handler(_handle);
			}
		}

		/// <summary>
		/// Close the handle stored in this "unique_handle" object (if valid) and replace it with a new one.
		/// </summary>
		/// <param name="handle">Handle to be replaced</param>
		/// <returns></returns>
		__mixin_forceinline inline void reset(handle_t handle = invalid_handle_value) noexcept
		{
			if (handle == _handle) { return; }
			if (is_valid<handle_t>::call(_handle)) { close_handler(_handle); }

			_handle = handle;
		}

		/// <summary>
		/// Gets the handle stored in this "unique_handle" object, and then clears the stored handle (without calling the deleter)
		/// </summary>
		/// <returns>The handle stored in this "unique_handle" object.</returns>
		__mixin_forceinline inline handle_t release() noexcept
		{
			auto handle{ _handle };
			_handle = invalid_handle_value;
			return handle;
		}

		/// <summary>
		/// Get the handle stored in this "unique_handle" object
		/// </summary>
		/// <returns>Handle of the "unique_handle" object storage</returns>
		__mixin_forceinline inline handle_t get() const noexcept { return _handle; }

		/// <summary>
		/// Verify that the handle stored in the "unique_handle" object is valid.
		/// </summary>
		/// <returns>Returns true if this handle is not 0 or negative (depending on the provided validator)</returns>
		__mixin_forceinline inline bool valid() const noexcept { return is_valid<handle_t>::call(_handle); }
		__mixin_forceinline inline operator bool() const noexcept { return valid(); }
		__mixin_forceinline inline operator handle_t() const noexcept { return _handle; }
		__mixin_forceinline inline handle_t* operator &() const noexcept { return &_handle; }

		__mixin_forceinline inline unique_handle& operator=(unique_handle&& other) noexcept
		{
			if (std::addressof(other) == this)
			{
				return *this;
			}

			reset(other._handle);
			other._handle = invalid_handle_value;
			return *this;
		}

		__mixin_forceinline inline unique_handle& operator=(handle_t handle) noexcept
		{
			reset(handle);
			return *this;
		}

		__mixin_forceinline inline bool operator==(unique_handle const& other) const noexcept { return _handle == other._handle; }
	};

	/// <summary>
	/// Normal handle, non-zero is considered valid, and "CloseHandle" is used as the deleter.
	/// </summary>
	using handle = unique_handle<HANDLE, &CloseHandle>;

	/// <summary>
	/// Service handle, non-zero is considered valid. and "CloseServiceHandle" is used as the deleter.
	/// </summary>
	using service_handle = unique_handle<SC_HANDLE, &CloseServiceHandle>;

	/// <summary>
	/// Represents the handle of a process or thread.
	/// <para>Special values (-1 or -2) and non-negative values indicating the current process or thread are considered valid.</para>
	/// <para>"CloseHandle" is used as the deleter.</para>
	/// </summary>
	using process_handle = unique_handle<HANDLE, &CloseHandle, with_pseudo<non_negative>::type>;

	/// <summary>
	/// Represents the handle of a activation context, non-zero is considered valid, and "ReleaseActCtx" is used as the deleter.
	/// </summary>
	using actx_handle = unique_handle<HANDLE, &ReleaseActCtx>;

	/// <summary>
	/// Represents the handle of a registry key, non-zero is considered value, and "RegCloseKey" is used as the deleter.
	/// </summary>
	using reg_handle = unique_handle<HKEY, &RegCloseKey>;

	/// <summary>
	/// Represents the handle of a mapped view, non-zero is considered value, and "UnmapViewOfFile" is used as the deleter.
	/// </summary>
	using mapping_handle = unique_handle<void*, &UnmapViewOfFile, non_zero>;

	constexpr auto _Time = __TIME__;
	constexpr auto _Seed = static_cast<int>(_Time[7]) + static_cast<int>(_Time[6]) * 10 + static_cast<int>(_Time[4]) * 60 + static_cast<int>(_Time[3]) * 600
		+ static_cast<int>(_Time[1]) * 3600 + static_cast<int>(_Time[0]) * 36000;

	/// <summary>
	/// 1988, Stephen Park and Keith Miller
	/// "Random Number Generators: Good Ones Are Hard To Find", considered as "minimal standard"
	/// Park-Miller 31 bit pseudo-random number generator, implemented with G. Carta's optimisation:
	/// with 32-bit math and without division
	/// </summary>
	/// <typeparam name="v">i don't know</typeparam>
	template<unsigned v>
	struct random_generator
	{
	private:
		static constexpr unsigned a = 16807; // 7^5
		static constexpr unsigned m = 2147483647; // 2^31 - 1

		static constexpr unsigned s = random_generator<v - 1 >::value;
		static constexpr unsigned lo = a * (s & 0xFFFF); // Multiply lower 16 bits by 16807
		static constexpr unsigned hi = a * (s >> 16); // Multiply higher 16 bits by 16807
		static constexpr unsigned lo2 = lo + ((hi & 0x7FFF) << 16); // Combine lower 15 bits of hi with lo's upper bits
		static constexpr unsigned hi2 = hi >> 15; // Discard lower 15 bits of hi
		static constexpr unsigned lo3 = lo2 + hi;

	public:
		static constexpr unsigned max = m;
		static constexpr unsigned value = lo3 > m ? lo3 - m : lo3;
	};

	template<>
	struct random_generator<0>
	{
		static constexpr unsigned value = _Seed;
	};

	template<unsigned n, unsigned m>
	struct random_int
	{
		static constexpr auto value = random_generator<n + 1>::value & m;
	};

	template<unsigned n>
	struct random_char
	{
		static const char value = static_cast<char>(1 + random_int<n, 0x7F - 1 >::value);
	};

	template<std::size_t n, int k, character char_type = mixins::char_type>
	struct xor_string
	{
	private:
		const char _key;
		std::array<char_type, n + 1> _encrypted;

		constexpr char_type enc(char_type c) const
		{
			return c ^ _key;
		}

		char_type dec(char_type c) const
		{
			return c ^ _key;
		}

	public:
		template<std::size_t... indexs>
		constexpr xor_string(char_type const* str, std::index_sequence<indexs...>) : _key{ random_char<k>::value }, _encrypted{ enc(str[indexs])... }
		{

		}

		__mixin_forceinline decltype(auto) decrypt()
		{
			for (index i{}; i < n; i++)
			{
				_encrypted[i] = dec(_encrypted[i]);
			}

			_encrypted[n] = '\0';
			return _encrypted.data();
		}
	};

	#define __xor_string(s) []{ constexpr mixins::xor_string<sizeof(s) / sizeof(typename mixins::char_type_t<decltype(s)>) - 1, __COUNTER__, typename mixins::char_type_t<decltype(s)>> expr(s, std::make_index_sequence<sizeof(s) / sizeof(typename mixins::char_type_t<decltype(s)>) - 1>()); return expr; }().decrypt()

	template<typename T, std::size_t size>
	struct basic_string_literal
	{
		using char_type = T;
		constexpr static std::size_t length{ size };
		char_type data[length + 1]{};

		template<std::size_t _size = size, std::enable_if_t<_size == 0, std::size_t> = 0> constexpr basic_string_literal() :data{ 0 } {}
		template<std::size_t _size = size, std::enable_if_t<_size == 1, std::size_t> = 0> constexpr basic_string_literal(char_type c) : data{ c,0 } {}
		constexpr basic_string_literal(std::basic_string_view<char_type> view)
		{
			for (std::size_t i{}; i < length; i++) { data[i] = view[i]; }
			data[size] = 0;
		}

		constexpr basic_string_literal(const char_type(&value)[size + 1])
		{
			for (std::size_t i{}; i < length; i++) { data[i] = value[i]; }
			data[size] = 0;
		}
	};

	template<typename T, std::size_t N>
	basic_string_literal(T const(&)[N])->basic_string_literal<T, N - 1>;

	template<basic_string_literal basic_string_literal_v>
	struct string_literal
	{
		using char_type = typename decltype(basic_string_literal_v)::char_type;
		static constexpr char_type* data() { return basic_string_literal_v.data; }
		static constexpr std::size_t length() { return basic_string_literal_v.length; }
		static constexpr std::basic_string_view<char_type> view() { return basic_string_literal_v.data; }
		constexpr operator std::basic_string_view<char_type>() { return view(); }
	};

	#define __literal(str) \
	([]{constexpr std::basic_string_view s{str};\
	    return mixins::string_literal<\
	        mixins::basic_string_literal<typename decltype(s)::value_type,s.size()>\
	            {str}>{};}\
	())

	template<character char_type = typename mixins::char_type>
	__mixin_forceinline [[nodiscard]] inline std::basic_string<char_type> to_string(char_type const* value) noexcept
	{
		return std::basic_string<char_type>{ value };
	}

	template<character char_type = typename mixins::char_type, std::floating_point T /* mixins::iec559 ? */>
	__mixin_forceinline [[nodiscard]] inline std::basic_string<char_type> to_string(T const value) noexcept
	{
		if constexpr (std::is_same_v<char_type, char>)
		{
			return std::to_string(value);
		}
		else
		{
			return std::to_wstring(value);
		}
	}

	template<character char_type = typename mixins::char_type, std::integral T> requires not_boolean<T>
	__mixin_forceinline [[nodiscard]] inline std::basic_string<char_type> to_string(T const value) noexcept
	{
		if constexpr (std::is_same_v<char_type, char>)
		{
			return std::to_string(value);
		}
		else
		{
			return std::to_wstring(value);
		}
	}


	template<character char_type = typename mixins::char_type, boolean T>
	__mixin_forceinline [[nodiscard]] inline std::basic_string<char_type> to_string(T const value) noexcept
	{
		if constexpr (std::is_same_v<char_type, char>)
		{
			return value ? __mixin_xor_string("True") : __mixin_xor_string("False");
		}
		else
		{
			return value ? __mixin_xor_string(L"True") : __mixin_xor_string(L"False");
		}
	}

	template<character char_type = typename mixins::char_type>
	__mixin_forceinline [[nodiscard]] inline std::basic_string<char_type>&& to_string(std::basic_string<char_type>&& value) noexcept
	{
		return std::forward<std::basic_string<char_type>>(value);
	}

	template<character char_type = typename mixins::char_type>
	__mixin_forceinline [[nodiscard]] inline std::basic_string<char_type> const& to_string(std::basic_string<char_type> const& value) noexcept
	{
		return value;
	}

	template<character char_type = typename mixins::char_type>
	__mixin_forceinline [[nodiscard]] inline std::basic_string<char_type> to_string(std::basic_string_view<char_type>&& value) noexcept
	{
		return value.data();
	}

	template<character char_type = typename mixins::char_type>
	__mixin_forceinline [[nodiscard]] inline std::basic_string<char_type> to_string(std::basic_string_view<char_type> const& value) noexcept
	{
		return value.data();
	}

	template<character char_type = typename mixins::char_type, std::ranges::range container_t> requires not_string<container_t>
	__mixin_forceinline [[nodiscard]] inline std::basic_string<char_type> to_string(container_t const& container) noexcept
	{
		std::vector<std::basic_string<char_type>> buffer;
		buffer.emplace_back(__mixin_xor_string("["));

		for (auto&& v : container)
		{
			if constexpr (std::convertible_to<decltype(v), std::basic_string<char_type>> || std::convertible_to<decltype(v), std::basic_string_view<char_type>>)
			{
				buffer.emplace_back(__mixin_xor_string("\""));
				buffer.emplace_back(to_string<char_type>(v));
				buffer.emplace_back(__mixin_xor_string("\""));
			}
			else
			{
				buffer.emplace_back(to_string<char_type>(v));
			}

			buffer.emplace_back(__mixin_xor_string(","));
		}

		buffer.pop_back();
		buffer.emplace_back(__mixin_xor_string("]"));
		return connect<char_type, decltype(buffer), false>(buffer);
	}

	__mixin_forceinline constexpr char _Hex(auto const value)
	{
		if constexpr (std::is_constant_evaluated())
		{
			return "0123456789ABCDEF"[value & 0xF];
		}
		else
		{
			return __mixin_xor_string("0123456789ABCDEF")[value & 0xF];
		}
	}

	template<character char_type = typename mixins::char_type, std::integral T>
	__mixin_forceinline [[nodiscard]] inline std::basic_string<char_type> hex(T value) noexcept
	{
		if (value == 0)
		{
			return "0";
		}

		if (value > 0xF)
		{
			T temp{};
			char buffer[sizeof(T) * 2]{};
			std::uint8_t i{ sizeof(T) * 2 - 1 };

			while (value >= 16)
			{
				temp = value % 16;
				value >>= 4; // value /= 16;
				buffer[i--] = _Hex(temp);
			}

			buffer[i] = _Hex(value);
			return std::basic_string<char_type>(buffer, std::end(buffer));
		}
		else
		{
			auto result{ _Hex(value) };
			return std::basic_string<char_type>(result, 1);
		}
	}

	template<character char_type = typename mixins::char_type>
	__mixin_forceinline [[nodiscard]] inline std::basic_string<char_type> hex(void* value) noexcept
	{
		return hex(reinterpret_cast<std::uint64_t>(value));
	}

	template<character char_type = typename mixins::char_type, std::integral T>
	__mixin_forceinline [[nodiscard]] inline std::basic_string<char_type> hex(T* value) noexcept
	{
		return hex(reinterpret_cast<std::uint64_t>(value));
	}

	template<character char_type = typename mixins::char_type, typename...args_t>
	__mixin_forceinline [[nodiscard]] inline std::basic_string<char_type> connect(args_t const&... v)
	{
		std::basic_string<char_type> buffer;
		std::size_t length{};
		((length += std::basic_string_view<char_type>(v).size()), ...);
		buffer.reserve(length);
		((buffer += std::basic_string_view<char_type>(v)), ...);
		return buffer;
	}

	template<character char_type = typename mixins::char_type, std::ranges::range container_t, bool>
	__mixin_forceinline [[nodiscard]] inline std::basic_string<char_type> connect(container_t const& container)
	{
		std::size_t size{};

		for (auto&& v : container)
		{
			size += v.size();
		}

		std::basic_string<char_type> buffer;
		buffer.reserve(size);

		for (auto&& v : container)
		{
			buffer += v;
		}

		return buffer;
	}
	template<character char_type = typename mixins::char_type, typename...args_t>
	[[nodiscard]] inline std::basic_string<char_type> concat(args_t const&... v)
	{
		return connect<char_type>(to_string<char_type>(v)...);
	}

	template<typename T>
	struct generator
	{
		struct promise_type;
		using handle_type = std::coroutine_handle<promise_type>;

		struct promise_type
		{
			T value{};
			std::exception_ptr exception;

			generator get_return_object() { return generator{ handle_type::from_promise(*this) }; }
			std::suspend_always initial_suspend() { return {}; }
			std::suspend_always final_suspend() noexcept { return {}; }
			void unhandled_exception() { exception = std::current_exception(); }

			template<std::convertible_to<T> from_t>
			std::suspend_always yield_value(from_t&& from)
			{
				value = std::forward<from_t>(from);
				return {};
			}

			void return_void() {}
		};

		handle_type handle;

		generator(handle_type handle) : handle{ handle } {}
		~generator() { handle.destroy(); }
		explicit operator bool()
		{
			fill();
			return !handle.done();
		}

		T operator()()
		{
			fill();
			_full = false;
			return std::move(handle.promise().value);
		}

	private:
		bool _full{ false };

		void fill()
		{
			if (!_full)
			{
				handle();
				if (handle.promise().exception) { std::rethrow_exception(handle.promise().exception); }
				_full = true;
			}
		}
	};

	template<character char_type = typename mixins::char_type, unsigned long handle = STD_OUTPUT_HANDLE, typename...args_t>
	__mixin_forceinline inline bool print(args_t const&...args) noexcept
	{
		auto buffer{ concat<char_type>(args...) };

		if constexpr (std::is_same_v<char_type, char>)
		{
			return WriteConsoleA(GetStdHandle(handle), buffer.data(), buffer.size(), nullptr, nullptr);
		}
		else
		{
			return WriteConsoleW(GetStdHandle(handle), buffer.data(), buffer.size(), nullptr, nullptr);
		}
	}

	template<character char_type = typename mixins::char_type, unsigned long handle = STD_OUTPUT_HANDLE, typename...args_t>
	__mixin_forceinline inline bool println(args_t const&...args) noexcept
	{
		if constexpr (std::is_same_v<char_type, char>)
		{
			auto buffer{ concat<char_type>(args..., "\n") };
			return WriteConsoleA(GetStdHandle(handle), buffer.data(), static_cast<unsigned long>(buffer.size()), nullptr, nullptr);
		}
		else
		{
			auto buffer{ concat<char_type>(args..., L"\n") };
			return WriteConsoleW(GetStdHandle(handle), buffer.data(), static_cast<unsigned long>(buffer.size()), nullptr, nullptr);
		}
	}

	constexpr unsigned int _Crc32_table[]{
		0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
		0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
		0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
		0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
		0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
		0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
		0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,
		0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
		0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
		0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
		0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,
		0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
		0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
		0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
		0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
		0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
		0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
		0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
		0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
		0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
		0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
		0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
		0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
		0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
		0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
		0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
		0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
		0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
		0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
		0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
		0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
		0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
		0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
		0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
		0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
		0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
		0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
		0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
		0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
		0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
		0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
		0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
		0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
	};

	/// <summary>
	/// Calculate the CRC32 checksum value of the specified size buffer.
	/// </summary>
	/// <param name="buffer">Buffer to be calculated.</param>
	/// <param name="length">Buffer size.</param>
	/// <returns>Checksum</returns>
	__mixin_forceinline inline unsigned const compute_crc32(void* buffer, std::size_t length) noexcept
	{
		if (length < 1) { return 0xFFFFFFFF; }
		unsigned int crc{};
		for (std::size_t i{}; i < length; i++) { crc = _Crc32_table[(crc ^ reinterpret_cast<unsigned char*>(buffer)[i]) & 0xFF] ^ (crc >> 8); }
		return crc ^= 0xFFFFFFFF;
	}

	/// <summary>
	/// Calculates the Crc32 value of the specified object.
	/// </summary>
	/// <param name="value">Object to be calculated.</param>
	/// <returns>Checksum.</returns>
	template<typename T>
	__mixin_forceinline inline unsigned const compute_crc32(const T& value) noexcept
	{
		return compute_crc32(reinterpret_cast<void*>(const_cast<T*>(&value)), sizeof(T));
	}

	namespace _Native
	{

		struct LIST_ENTRY_T
		{
			char const* Flink;
			char const* Blink;
		};

		struct UNICODE_STRING_T
		{
			unsigned short Length;
			unsigned short MaximumLength;
			wchar_t* Buffer;
		};

		struct PEB_LDR_DATA_T
		{
			unsigned long Length;
			unsigned long Initialized;
			char const* SsHandle;
			LIST_ENTRY_T  InLoadOrderModuleList;
		};

		struct PEB_T
		{
			unsigned char   Reserved1[2];
			unsigned char   BeingDebugged;
			unsigned char   Reserved2[1];
			char const* Reserved3[2];
			PEB_LDR_DATA_T* ldr_t;
		};

		struct LDR_DATA_TABLE_ENTRY_T
		{
			LIST_ENTRY_T InLoadOrderLinks;
			LIST_ENTRY_T InMemoryOrderLinks;
			LIST_ENTRY_T InInitializationOrderLinks;
			char const* DllBase;
			char* EntryPoint;
			union
			{
				unsigned long SizeOfImage;
				char const* _dummy;
			};
			UNICODE_STRING_T FullDllName;
			UNICODE_STRING_T BaseDllName;

			__mixin_forceinline const LDR_DATA_TABLE_ENTRY_T*
				load_order_next() const noexcept
			{
				return reinterpret_cast<LDR_DATA_TABLE_ENTRY_T const*>(
					InLoadOrderLinks.Flink);
			}
		};

		struct IMAGE_DOS_HEADER
		{ // DOS .EXE header
			unsigned short e_magic; // Magic number
			unsigned short e_cblp; // Bytes on last page of file
			unsigned short e_cp; // Pages in file
			unsigned short e_crlc; // Relocations
			unsigned short e_cparhdr; // Size of header in paragraphs
			unsigned short e_minalloc; // Minimum extra paragraphs needed
			unsigned short e_maxalloc; // Maximum extra paragraphs needed
			unsigned short e_ss; // Initial (relative) SS value
			unsigned short e_sp; // Initial SP value
			unsigned short e_csum; // Checksum
			unsigned short e_ip; // Initial IP value
			unsigned short e_cs; // Initial (relative) CS value
			unsigned short e_lfarlc; // File address of relocation table
			unsigned short e_ovno; // Overlay number
			unsigned short e_res[4]; // Reserved words
			unsigned short e_oemid; // OEM identifier (for e_oeminfo)
			unsigned short e_oeminfo; // OEM information; e_oemid specific
			unsigned short e_res2[10]; // Reserved words
			long           e_lfanew; // File address of new exe header
		};

		struct IMAGE_FILE_HEADER
		{
			unsigned short Machine;
			unsigned short NumberOfSections;
			unsigned long  TimeDateStamp;
			unsigned long  PointerToSymbolTable;
			unsigned long  NumberOfSymbols;
			unsigned short SizeOfOptionalHeader;
			unsigned short Characteristics;
		};

		struct IMAGE_EXPORT_DIRECTORY
		{
			unsigned long  Characteristics;
			unsigned long  TimeDateStamp;
			unsigned short MajorVersion;
			unsigned short MinorVersion;
			unsigned long  Name;
			unsigned long  Base;
			unsigned long  NumberOfFunctions;
			unsigned long  NumberOfNames;
			unsigned long  AddressOfFunctions; // RVA from base of image
			unsigned long  AddressOfNames; // RVA from base of image
			unsigned long  AddressOfNameOrdinals; // RVA from base of image
		};

		struct IMAGE_DATA_DIRECTORY
		{
			unsigned long VirtualAddress;
			unsigned long Size;
		};

		struct IMAGE_OPTIONAL_HEADER64
		{
			unsigned short       Magic;
			unsigned char        MajorLinkerVersion;
			unsigned char        MinorLinkerVersion;
			unsigned long        SizeOfCode;
			unsigned long        SizeOfInitializedData;
			unsigned long        SizeOfUninitializedData;
			unsigned long        AddressOfEntryPoint;
			unsigned long        BaseOfCode;
			unsigned long long   ImageBase;
			unsigned long        SectionAlignment;
			unsigned long        FileAlignment;
			unsigned short       MajorOperatingSystemVersion;
			unsigned short       MinorOperatingSystemVersion;
			unsigned short       MajorImageVersion;
			unsigned short       MinorImageVersion;
			unsigned short       MajorSubsystemVersion;
			unsigned short       MinorSubsystemVersion;
			unsigned long        Win32VersionValue;
			unsigned long        SizeOfImage;
			unsigned long        SizeOfHeaders;
			unsigned long        CheckSum;
			unsigned short       Subsystem;
			unsigned short       DllCharacteristics;
			unsigned long long   SizeOfStackReserve;
			unsigned long long   SizeOfStackCommit;
			unsigned long long   SizeOfHeapReserve;
			unsigned long long   SizeOfHeapCommit;
			unsigned long        LoaderFlags;
			unsigned long        NumberOfRvaAndSizes;
			IMAGE_DATA_DIRECTORY DataDirectory[16];
		};

		struct IMAGE_OPTIONAL_HEADER32
		{
			unsigned short       Magic;
			unsigned char        MajorLinkerVersion;
			unsigned char        MinorLinkerVersion;
			unsigned long        SizeOfCode;
			unsigned long        SizeOfInitializedData;
			unsigned long        SizeOfUninitializedData;
			unsigned long        AddressOfEntryPoint;
			unsigned long        BaseOfCode;
			unsigned long        BaseOfData;
			unsigned long        ImageBase;
			unsigned long        SectionAlignment;
			unsigned long        FileAlignment;
			unsigned short       MajorOperatingSystemVersion;
			unsigned short       MinorOperatingSystemVersion;
			unsigned short       MajorImageVersion;
			unsigned short       MinorImageVersion;
			unsigned short       MajorSubsystemVersion;
			unsigned short       MinorSubsystemVersion;
			unsigned long        Win32VersionValue;
			unsigned long        SizeOfImage;
			unsigned long        SizeOfHeaders;
			unsigned long        CheckSum;
			unsigned short       Subsystem;
			unsigned short       DllCharacteristics;
			unsigned long        SizeOfStackReserve;
			unsigned long        SizeOfStackCommit;
			unsigned long        SizeOfHeapReserve;
			unsigned long        SizeOfHeapCommit;
			unsigned long        LoaderFlags;
			unsigned long        NumberOfRvaAndSizes;
			IMAGE_DATA_DIRECTORY DataDirectory[16];
		};

		struct IMAGE_NT_HEADERS
		{
			unsigned long     Signature;
			IMAGE_FILE_HEADER FileHeader;
			#ifdef _WIN64
			IMAGE_OPTIONAL_HEADER64 OptionalHeader;
			#else
			IMAGE_OPTIONAL_HEADER32 OptionalHeader;
			#endif
		};

	}

	struct _Forwarded_hashes
	{
		unsigned module_hash;
		unsigned function_hash;
	};

	using _Offset_hash_pair = unsigned long long;

	__mixin_forceinline inline constexpr unsigned _Get_hash(_Offset_hash_pair pair) noexcept { return (pair & 0xFFFFFFFF); }

	__mixin_forceinline inline constexpr unsigned _Get_offset(_Offset_hash_pair pair) noexcept { return (pair >> 32); }

	template<bool case_sensitive = false>
	__mixin_forceinline inline constexpr unsigned _Hash_single(unsigned value, char c) noexcept
	{
		return static_cast<unsigned int>(
			(value ^ ((case_sensitive && c >= 'A' && c <= 'Z') ? (c | (1 << 5)) : c)) *
			static_cast<unsigned long long>(16777619));
	}

	__mixin_forceinline inline constexpr unsigned
		_Khash_impl(char const* str, unsigned value) noexcept
	{
		return (*str ? _Khash_impl(str + 1, _Hash_single(value, *str)) : value);
	}

	__mixin_forceinline inline constexpr _Offset_hash_pair _Khash(
		char const* str, unsigned offset) noexcept
	{
		return ((_Offset_hash_pair{ offset } << 32) | _Khash_impl(str, offset));
	}

	template<class char_type = char>
	__mixin_forceinline inline unsigned _Hash(char_type const* str, unsigned offset) noexcept
	{
		unsigned value = offset;

		for (;;)
		{
			char c = *str++;
			if (!c)
				return value;
			value = _Hash_single(value, c);
		}
	}

	__mixin_forceinline inline unsigned _Hash(
		_Native::UNICODE_STRING_T const& str, unsigned offset) noexcept
	{
		auto       first = str.Buffer;
		const auto last = first + (str.Length / sizeof(wchar_t));
		auto       value = offset;
		for (; first != last; ++first)
			value = _Hash_single(value, static_cast<char>(*first));

		return value;
	}

	__mixin_forceinline inline _Forwarded_hashes _Hash_forwarded(
		char const* str, unsigned offset) noexcept
	{
		_Forwarded_hashes res{ offset, offset };

		for (; *str != '.'; ++str)
			res.module_hash = _Hash_single<true>(res.module_hash, *str);

		++str;

		for (; *str; ++str)
			res.function_hash = _Hash_single(res.function_hash, *str);

		return res;
	}

	__mixin_forceinline inline _Native::PEB_T const* _Peb() noexcept
	{
		#if defined(_M_X64) || defined(__amd64__)
		return reinterpret_cast<_Native::PEB_T const*>(__readgsqword(0x60));
		#elif defined(_M_IX86) || defined(__i386__)
		return reinterpret_cast<_Native::PEB_T const*>(__readfsdword(0x30));
		#elif defined(_M_ARM) || defined(__arm__)
		return *reinterpret_cast<_Native::PEB_T const**>(_MoveFromCoprocessor(15, 0, 13, 0, 2) + 0x30);
		#elif defined(_M_ARM64) || defined(__aarch64__)
		return *reinterpret_cast<_Native::PEB_T const**>(__getReg(18) + 0x60);
		#elif defined(_M_IA64) || defined(__ia64__)
		return *reinterpret_cast<_Native::PEB_T const**>(static_cast<char*>(_rdteb()) + 0x60);
		#else
		#error Unsupported platform.
		#endif
	}

	__mixin_forceinline inline _Native::PEB_LDR_DATA_T const* _Ldr()
	{
		return reinterpret_cast<_Native::PEB_LDR_DATA_T const*>(_Peb()->ldr_t);
	}

	__mixin_forceinline inline _Native::IMAGE_NT_HEADERS const* _Nt_headers(
		const char* base) noexcept
	{
		return reinterpret_cast<_Native::IMAGE_NT_HEADERS const*>(
			base + reinterpret_cast<_Native::IMAGE_DOS_HEADER const*>(base)->e_lfanew);
	}

	__mixin_forceinline inline _Native::IMAGE_EXPORT_DIRECTORY const* _Image_export_dir(
		const char* base) noexcept
	{
		return reinterpret_cast<_Native::IMAGE_EXPORT_DIRECTORY const*>(
			base + _Nt_headers(base)->OptionalHeader.DataDirectory->VirtualAddress);
	}

	__mixin_forceinline inline _Native::LDR_DATA_TABLE_ENTRY_T const* _Ldr_data_entry() noexcept
	{
		return reinterpret_cast<_Native::LDR_DATA_TABLE_ENTRY_T const*>(
			_Ldr()->InLoadOrderModuleList.Flink);
	}

	struct _Exports_directory
	{
		char const* _base;
		_Native::IMAGE_EXPORT_DIRECTORY const* _ied;
		unsigned long                      _ied_size;

	public:
		using size_type = unsigned long;

		__mixin_forceinline
			_Exports_directory(char const* base) noexcept : _base(base)
		{
			auto const ied_data_dir = _Nt_headers(base)->OptionalHeader.DataDirectory[0];
			_ied = reinterpret_cast<const _Native::IMAGE_EXPORT_DIRECTORY*>(
				base + ied_data_dir.VirtualAddress);
			_ied_size = ied_data_dir.Size;
		}

		__mixin_forceinline explicit operator bool() const noexcept
		{
			return reinterpret_cast<char const*>(_ied) != _base;
		}

		__mixin_forceinline size_type size() const noexcept
		{
			return _ied->NumberOfNames;
		}

		__mixin_forceinline char const* base() const noexcept { return _base; }
		__mixin_forceinline _Native::IMAGE_EXPORT_DIRECTORY const* ied() const noexcept
		{
			return _ied;
		}

		__mixin_forceinline char const* name(size_type index) const noexcept
		{
			return reinterpret_cast<const char*>(
				_base + reinterpret_cast<const unsigned long*>(
					_base + _ied->AddressOfNames)[index]);
		}

		__mixin_forceinline const char* address(size_type index) const noexcept
		{
			const auto* const rva_table =
				reinterpret_cast<const unsigned long*>(_base + _ied->AddressOfFunctions);

			const auto* const ord_table = reinterpret_cast<unsigned short const*>(
				_base + _ied->AddressOfNameOrdinals);

			return _base + rva_table[ord_table[index]];
		}

		__mixin_forceinline bool is_forwarded(
			char const* export_address) const noexcept
		{
			auto const ui_ied = reinterpret_cast<char const*>(_ied);
			return (export_address > ui_ied && export_address < ui_ied + _ied_size);
		}
	};

	struct _Safe_module_enumerator
	{
		using value_type = _Native::LDR_DATA_TABLE_ENTRY_T const;
		value_type* value;
		value_type* head;

		__mixin_forceinline _Safe_module_enumerator() noexcept
			: _Safe_module_enumerator(_Ldr_data_entry())
		{
		}

		__mixin_forceinline
			_Safe_module_enumerator(_Native::LDR_DATA_TABLE_ENTRY_T const* _Ldr) noexcept
			: value(_Ldr->load_order_next()), head(value)
		{
		}

		__mixin_forceinline void reset() noexcept
		{
			value = head->load_order_next();
		}

		__mixin_forceinline bool next() noexcept
		{
			value = value->load_order_next();

			return value != head && value->DllBase;
		}
	};

	struct _Unsafe_module_enumerator
	{
		using value_type = _Native::LDR_DATA_TABLE_ENTRY_T const*;
		value_type value;

		__mixin_forceinline _Unsafe_module_enumerator() noexcept
			: value(_Ldr_data_entry())
		{
		}

		__mixin_forceinline void reset() noexcept { value = _Ldr_data_entry(); }

		__mixin_forceinline bool next() noexcept
		{
			value = value->load_order_next();
			return true;
		}
	};

	template<class derived_t, class default_t = void*>
	class _Lazy_base
	{
	protected:
		__mixin_forceinline static void*& _cache() noexcept
		{
			static void* value{ nullptr };
			return value;
		}

	public:
		template<class T = default_t>
		__mixin_forceinline static T safe() noexcept
		{
			return derived_t::template get<T, _Safe_module_enumerator>();
		}

		template<class T = default_t, class enumerator_t = _Unsafe_module_enumerator>
		__mixin_forceinline static T cached() noexcept
		{
			auto& cached = _cache();
			if (!cached)
				cached = derived_t::template get<void*, enumerator_t>();

			return reinterpret_cast<T>(cached);
		}

		template<class T = default_t>
		__mixin_forceinline static T safe_cached() noexcept
		{
			return cached<T, _Safe_module_enumerator>();
		}
	};

	template<_Offset_hash_pair OHP>
	struct _Lazy_module : _Lazy_base<_Lazy_module<OHP>>
	{
		template<class T = void*, class enumerator_t = _Unsafe_module_enumerator>
		__mixin_forceinline static T get() noexcept
		{
			enumerator_t e{};
			do
			{
				if (_Hash(e.value->BaseDllName, _Get_offset(OHP)) == _Get_hash(OHP)) { return reinterpret_cast<T>(e.value->DllBase); }
			} while (e.next());
			return {};
		}

		template<class T = void*, class ldr_t>
		__mixin_forceinline static T in(ldr_t _Ldr) noexcept
		{
			_Safe_module_enumerator e(reinterpret_cast<_Native::LDR_DATA_TABLE_ENTRY_T const*>(_Ldr));
			do
			{
				if (_Hash(e.value->BaseDllName, _Get_offset(OHP)) == _Get_hash(OHP)) { return reinterpret_cast<T>(e.value->DllBase); }
			} while (e.next());
			return {};
		}

		template<class T = void*, class ldr_t>
		__mixin_forceinline static T in_cached(ldr_t _Ldr) noexcept
		{
			auto& cached = _Lazy_base<_Lazy_module<OHP>>::_cache();
			if (!cached) { cached = in(_Ldr); }

			return reinterpret_cast<T>(cached);
		}
	};

	template<_Offset_hash_pair OHP, class T>
	struct _Lazy_function : _Lazy_base<_Lazy_function<OHP, T>, T>
	{
		using base_type = _Lazy_base<_Lazy_function<OHP, T>, T>;

		template<class... Args>
		__mixin_forceinline decltype(auto) operator()(Args&&... args) const noexcept
		{
			#ifndef __cache_operator_parnes
			return get()(std::forward<Args>(args)...);
			#else
			return this->cached()(std::forward<Args>(args)...);
			#endif
		}

		template<class type = T, class enumerator_t = _Unsafe_module_enumerator>
		__mixin_forceinline static type get() noexcept
		{
			#ifdef __resolve_forwarded_exports__
			return forwarded<F, Enum>();
			#else

			enumerator_t e{};

			do
			{
				#ifdef __hardned_module_checks__
				if (!e.value->DllBase || !e.value->FullDllName.Length)
					continue;
				#endif

				_Exports_directory const exports(e.value->DllBase);

				if (exports)
				{
					auto export_index = exports.size();
					while (export_index--)
					{
						if (_Hash(exports.name(export_index), _Get_offset(OHP)) == _Get_hash(OHP)) { return reinterpret_cast<type>(exports.address(export_index)); }
					}
				}
			} while (e.next());
			return {};
			#endif
		}

		template<class type = T, class enumerator_t = _Unsafe_module_enumerator>
		__mixin_forceinline static type forwarded() noexcept
		{
			_Native::UNICODE_STRING_T name;
			_Forwarded_hashes hashes{ 0, _Get_hash(OHP) };

			enumerator_t e{};
			do
			{
				name = e.value->BaseDllName;
				name.Length -= 8;

				if (!hashes.module_hash || _Hash(name, _Get_offset(OHP)) == hashes.module_hash)
				{
					_Exports_directory const exports(e.value->DllBase);

					if (exports)
					{
						auto export_index = exports.size();
						while (export_index--)
							if (_Hash(exports.name(export_index), _Get_offset(OHP)) == hashes.function_hash)
							{
								const auto addr = exports.address(export_index);

								if (exports.is_forwarded(addr))
								{
									hashes = _Hash_forwarded(
										reinterpret_cast<char const*>(addr),
										_Get_offset(OHP));

									e.reset();
									break;
								}
								return reinterpret_cast<type>(addr);
							}
					}
				}
			} while (e.next());
			return {};
		}

		template<class type = T>
		__mixin_forceinline static type forwarded_safe() noexcept
		{
			return forwarded<type, _Safe_module_enumerator>();
		}

		template<class type = T, class enumerator_t = _Unsafe_module_enumerator>
		__mixin_forceinline static type forwarded_cached() noexcept
		{
			auto& value = base_type::_cache();
			if (!value) { value = forwarded<void*, enumerator_t>(); }
			return reinterpret_cast<type>(value);
		}

		template<class type = T>
		__mixin_forceinline static type forwarded_safe_cached() noexcept
		{
			return forwarded_cached<type, _Safe_module_enumerator>();
		}

		template<class type = T, bool safe = false, class module_t>
		__mixin_forceinline static type in(module_t m) noexcept
		{
			if (safe && !m) { return {}; }

			_Exports_directory const exports(reinterpret_cast<char* const>(m));
			if (safe && !exports)
				return {};

			for (unsigned long i{};; ++i)
			{
				if (safe && i == exports.size())
					break;

				if (_Hash(exports.name(i), _Get_offset(OHP)) == _Get_hash(OHP))
					return (type)(exports.address(i));
			}
			return {};
		}

		template<class type = T, class module_t>
		__mixin_forceinline static type in_safe(module_t m) noexcept
		{
			return in<type, true>(m);
		}

		template<class type = T, bool safe = false, class module_t>
		__mixin_forceinline static type in_cached(module_t m) noexcept
		{
			auto& value = base_type::_cache();
			if (!value)
				value = in<void*, safe>(m);
			return (type)(value);
		}

		template<class type = T, class module_t>
		__mixin_forceinline static type in_safe_cached(module_t m) noexcept
		{
			return in_cached<type, true>(m);
		}

		template<class type = T>
		__mixin_forceinline static type nt() noexcept
		{
			return in<type>(_Ldr_data_entry()->load_order_next()->DllBase);
		}

		template<class type = T>
		__mixin_forceinline static type nt_safe() noexcept
		{
			return in_safe<type>(_Ldr_data_entry()->load_order_next()->DllBase);
		}

		template<class type = T>
		__mixin_forceinline static type nt_cached() noexcept
		{
			return in_cached<type>(_Ldr_data_entry()->load_order_next()->DllBase);
		}

		template<class type = T>
		__mixin_forceinline static type nt_safe_cached() noexcept
		{
			return in_safe_cached<type>(_Ldr_data_entry()->load_order_next()->DllBase);
		}
	};

	#define __stringize(x) #x

	constexpr auto _Hash_name(char const* name) noexcept
	{
		return _Khash(name, _Khash_impl(__TIME__ __DATE__ __stringize(__LINE__) __stringize(__COUNTER__), 2166136261));
	}

	#define native(name) mixins::_Lazy_function<mixins::_Hash_name(#name), decltype(&name)>()

	/// <summary>
	/// Provides access to local processes and enables you to start and stop local system processes.
	/// </summary>
	template <character char_type = typename mixins::char_type>
	class basic_process
	{
	private:
		static_assert(std::is_same_v<char_type, char> || std::is_same_v<char_type, wchar_t>, "Unsupported char type.");

		unsigned int _id;
		std::basic_string<char_type> _name;
		mutable std::basic_string<char_type> _path;
		mutable process_handle _handle;
		basic_process() noexcept : _id{} {};

		using entry_t = std::conditional_t<std::is_same_v<char_type, char>, tagPROCESSENTRY32, PROCESSENTRY32W>;
	public:

		/// <summary>
		/// Represents an operating system process thread.
		/// </summary>
		class thread
		{
			friend basic_process;

		private:
			unsigned int _id;
			mutable process_handle _handle;
			thread() noexcept : _id(0) {}

		public:

			/// <summary>
			/// Gets the thread id of this "thread" object.
			/// </summary>
			/// <returns>Thread id.</returns>
			__mixin_forceinline inline unsigned int id() const noexcept { return _id; }

			/// <summary>
			/// Gets the handle of this "thread" object.
			/// </summary>
			/// <param name="access">Desired access, if the handle is already open, this parameter is ignored.</param>
			/// <returns>The process handle.</returns>
			__mixin_forceinline inline process_handle& handle(unsigned long access = THREAD_ALL_ACCESS) const noexcept
			{
				if (_handle) { return _handle; }

				return _handle = OpenThread(access, false, _id);
			}

			/// <summary>
			/// Forces termination of the underlying thread.
			/// </summary>
			/// <returns>If the function succeeds, the return value is true.</returns>
			__mixin_forceinline inline bool terminate() noexcept {}
		};

		/// <summary>
		/// Represents a.dll or .exe file that is loaded into a particular process.
		/// </summary>
		class module
		{
			friend basic_process;

		private:
			void* _base_address;
			HMODULE _handle;
			std::basic_string<char_type> _name;
			std::basic_string<char_type> _module_name;
			std::size_t _size;
			module() noexcept : _base_address{ nullptr }, _handle{ nullptr }, _size{ 0 } {}
		public:

			/// <summary>
			/// Gets the memory address where the module was loaded.
			/// </summary>
			/// <returns>The load address of the module.</returns>
			__mixin_forceinline inline void* base_address() const noexcept { return _base_address; }

			/// <summary>
			/// Gets the handle to the module in the context of the owning process.
			/// </summary>
			/// <returns>A handle to the module in the context of the owning process.</returns>
			__mixin_forceinline inline HMODULE handle() const noexcept { return _handle; }

			/// <summary>
			/// Gets the module name.
			/// </summary>
			/// <returns>The module name.</returns>
			__mixin_forceinline inline std::basic_string<char_type> const& name() const noexcept { return _name; }

			/// <summary>
			/// Gets the module path.
			/// </summary>
			/// <returns>The module path.</returns>
			__mixin_forceinline inline std::basic_string<char_type> const& path() const noexcept { return _module_name; }

			/// <summary>
			/// Gets the size of the module.
			/// </summary>
			/// <returns>The size of the module, in bytes.</returns>
			__mixin_forceinline inline std::size_t const size() const noexcept { return _size; }
		};

		/// <summary>
		/// Represents a block of memory that exists for a particular process.
		/// </summary>
		class memory
		{
			friend basic_process;
		private:
			void* _base_address;
			void* _allocation_base;
			std::uint32_t _allocation_protect;
			std::size_t _size;
			std::uint32_t _state;

		};

		/// <summary>
		/// Gets the process id of this "process" object.
		/// </summary>
		/// <returns>Process id.</returns>
		__mixin_forceinline inline unsigned int id() const noexcept { return _id; }

		/// <summary>
		/// Get the name of the process represented by this "process" object.
		/// </summary>
		/// <returns>Name of the process.</returns>
		__mixin_forceinline inline std::basic_string<char_type> const& name() const noexcept { return _name; }

		/// <summary>
		/// Get the full path of this process.
		/// </summary>
		/// <returns>Full path of the process.</returns>
		__mixin_forceinline inline std::basic_string<char_type> const& path() const noexcept
		{
			if (!_path.empty()) { return _path; }

			if constexpr (std::is_same_v<char_type, char>)
			{
				_path.resize(MAX_PATH);
				unsigned long size{ static_cast<unsigned long>(_path.size()) };
				if (QueryFullProcessImageNameA(handle(), 0, _path.data(), &size)) { _path.resize(size); }
			}
			else
			{
				_path.resize(MAX_PATH * 2);
				unsigned long size{ static_cast<unsigned long>(_path.size()) };
				if (QueryFullProcessImageNameW(handle(), 0, _path.data(), &size)) { _path.resize(size); }
			}

			return _path;
		}

		/// <summary>
		/// Gets the handle of this "process" object.
		/// </summary>
		/// <param name="access">Desired access, if the handle is already open, this parameter is ignored.</param>
		/// <returns>The process handle.</returns>
		__mixin_forceinline inline process_handle& handle(unsigned long access = PROCESS_ALL_ACCESS) const noexcept
		{
			if (_handle) { return _handle; }

			return _handle = OpenProcess(access, false, id());
		}

		/// <summary>
		/// Forces termination of the underlying process.
		/// </summary>
		/// <returns>If the function succeeds, the return value is true.</returns>
		__mixin_forceinline inline bool terminate(unsigned int exit_code = 0) const noexcept { return TerminateProcess(handle(), exit_code); }

		/// <summary>
		/// Gets all existing processes.
		/// </summary>
		/// <returns>
		/// If the function succeeds, the return value is a vector containing all existing process.
		/// <para/>
		/// If function fails, the return value is a empty vector.
		/// </returns>
		static std::vector<basic_process> const enumerate() noexcept
		{
			mixins::handle snapshot{ CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0) };
			if (!snapshot) { return std::vector<basic_process>{}; }

			std::vector<basic_process> processes;
			entry_t entry{ sizeof(entry) };

			if constexpr (std::is_same_v<char_type, char>)
			{
				if (!Process32First(snapshot, &entry)) { return std::vector<basic_process>{}; }

				do
				{
					basic_process<char> basic_process{};
					basic_process._name = entry.szExeFile;
					basic_process._id = entry.th32ProcessID;
					processes.emplace_back(std::move(basic_process));
				} while (Process32Next(snapshot, &entry));
			}
			else
			{
				if (!Process32FirstW(snapshot, &entry)) { return std::vector<basic_process>{}; }

				do
				{
					basic_process<wchar_t> basic_process{};
					basic_process._name = entry.szExeFile;
					basic_process._id = entry.th32ProcessID;
					processes.emplace_back(std::move(basic_process));
				} while (Process32NextW(snapshot, &entry));
			}

			return processes;
		}

		/// <summary>
		/// Gets all existing processes with the specified name.
		/// </summary>
		/// <returns>
		/// If the function succeeds, the return value is a vector containing all existing process with the specified name.
		/// <para/>
		/// If function fails, the return value is a empty vector.
		/// </returns>
		static std::vector<basic_process> const enumerate(std::basic_string_view<char_type> const& name) noexcept
		{
			mixins::handle snapshot{ CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0) };
			if (!snapshot) { return std::vector<basic_process>{}; }

			std::vector<basic_process> processes;
			entry_t entry{ sizeof(entry) };

			if constexpr (std::is_same_v<char_type, char>)
			{
				if (!Process32First(snapshot, &entry)) { return std::vector<basic_process>{}; }

				do
				{
					if (name.compare(entry.szExeFile) != 0) { continue; }

					basic_process basic_process{};
					basic_process._name = entry.szExeFile;
					basic_process._id = entry.th32ProcessID;
					processes.emplace_back(std::move(basic_process));
				} while (Process32Next(snapshot, &entry));
			}
			else
			{
				if (!Process32FirstW(snapshot, &entry)) { return std::vector<basic_process>{}; }

				do
				{
					if (name.compare(entry.szExeFile) != 0) { continue; }

					basic_process basic_process{};
					basic_process._name = entry.szExeFile;
					basic_process._id = entry.th32ProcessID;
					processes.emplace_back(std::move(basic_process));
				} while (Process32NextW(snapshot, &entry));
			}

			return processes;
		}

		/// <summary>
		/// Open a process based on its process ID.
		/// </summary>
		/// <returns>
		/// If the function succeeds, the return value is an optional containing the process with the specified name.
		/// <para/>
		/// If function fails, the return value is a empty optional.
		/// </returns>
		static std::optional<basic_process> const open(unsigned long id) noexcept
		{
			mixins::handle snapshot{ CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0) };
			if (!snapshot) { return std::nullopt; }

			entry_t entry{ sizeof(entry) };

			if constexpr (std::is_same_v<char_type, char>)
			{
				basic_process process{};
				process._id = id;
				process._name = process.path().substr(process.path().find_last_of("\\") + 1);
				return process;
			}
			else
			{
				basic_process process{};
				process._id = id;
				process._name = process.path().substr(process.path().find_last_of(L"\\") + 1);

				return process;
			}
		}

		/// <summary>
		/// Get the current process.
		/// </summary>
		/// <returns>This function has no failures and always returns a new instance of the "process" object for its own process.</returns>
		static basic_process current() noexcept
		{
			std::basic_string<char_type> buffer;
			if constexpr (std::is_same_v<char_type, char>)
			{
				buffer.resize(MAX_PATH);
				buffer.resize(GetModuleFileNameA(nullptr, buffer.data(), static_cast<unsigned long>(buffer.size())));
			}
			else
			{
				buffer.resize(MAX_PATH * 2);
				buffer.resize(GetModuleFileNameW(nullptr, buffer.data(), static_cast<unsigned long>(buffer.size())));
			}

			basic_process process{};
			process._id = GetCurrentProcessId();
			process._handle = GetCurrentProcess();

			std::exchange(process._name, buffer);
			process._name = process._name.substr(process._name.find_last_of("\\") + 1);
			return process;
		}

		#pragma region NATIVE_STRUCTURES

	private:
		template<typename T>
		struct _SYSTEM_HANDLE_T
		{
			std::uint32_t ProcessId;
			std::uint8_t ObjectTypeNumber;
			std::uint8_t Flags;
			std::uint16_t Handle;
			T Object;
			ACCESS_MASK GrantedAccess;
		};

		template<typename T>
		struct _SYSTEM_HANDLE_INFORMATION_T
		{
			std::uint32_t HandleCount;
			_SYSTEM_HANDLE_T<T> Handles[1];
		};

		using _SYSTEM_HANDLE_INFORMATION32 = _SYSTEM_HANDLE_INFORMATION_T<std::uint32_t>;
		using _SYSTEM_HANDLE_INFORMATION64 = _SYSTEM_HANDLE_INFORMATION_T<std::uint64_t>;
		using SYSTEM_HANDLE_INFORMATION_T = _SYSTEM_HANDLE_INFORMATION_T<std::uintptr_t>;

		enum POOL_TYPE
		{
			NonPagedPool,
			PagedPool,
			NonPagedPoolMustSucceed,
			DontUseThisType,
			NonPagedPoolCacheAligned,
			PagedPoolCacheAligned,
			NonPagedPoolCacheAlignedMustS
		};

		template <typename T>
		struct _UNICODE_STRING_T
		{
			using type = T;

			std::uint16_t Length;
			std::uint16_t MaximumLength;
			T Buffer;
		};

		template<typename T>
		struct _OBJECT_TYPE_INFORMATION_T
		{
			_UNICODE_STRING_T<T> Name;
			std::uint32_t TotalNumberOfObjects;
			std::uint32_t TotalNumberOfHandles;
			std::uint32_t TotalPagedPoolUsage;
			std::uint32_t TotalNonPagedPoolUsage;
			std::uint32_t TotalNamePoolUsage;
			std::uint32_t TotalHandleTableUsage;
			std::uint32_t HighWaterNumberOfObjects;
			std::uint32_t HighWaterNumberOfHandles;
			std::uint32_t HighWaterPagedPoolUsage;
			std::uint32_t HighWaterNonPagedPoolUsage;
			std::uint32_t HighWaterNamePoolUsage;
			std::uint32_t HighWaterHandleTableUsage;
			std::uint32_t InvalidAttributes;
			GENERIC_MAPPING GenericMapping;
			std::uint32_t ValidAccess;
			BOOLEAN SecurityRequired;
			BOOLEAN MaintainHandleCount;
			uint16_t MaintainTypeList;
			POOL_TYPE PoolType;
			std::uint32_t PagedPoolUsage;
			std::uint32_t NonPagedPoolUsage;
		};

		template<typename T>
		struct _SECTION_BASIC_INFORMATION_T
		{
			T Base;
			std::uint32_t Attributes;
			LARGE_INTEGER Size;
		};

		using _SECTION_BASIC_INFORMATION32 = _SECTION_BASIC_INFORMATION_T<std::uint32_t>;
		using _SECTION_BASIC_INFORMATION64 = _SECTION_BASIC_INFORMATION_T<std::uint64_t>;
		using SECTION_BASIC_INFORMATION_T = _SECTION_BASIC_INFORMATION_T<std::uintptr_t>;

		using _OBJECT_TYPE_INFORMATION32 = _OBJECT_TYPE_INFORMATION_T<std::uint32_t>;
		using _OBJECT_TYPE_INFORMATION64 = _OBJECT_TYPE_INFORMATION_T<std::uint64_t>;
		using OBJECT_TYPE_INFORMATION_T = _OBJECT_TYPE_INFORMATION_T<std::uintptr_t>;

		enum SECTION_INFORMATION_CLASS
		{
			SectionBasicInformation,
			SectionImageInformation
		};
		#pragma endregion

	public:

		class system_handle
		{
		public:
			struct section_info
			{
				std::uint64_t size;
				std::uint32_t attribute{};
			};

			HANDLE handle;
			std::uint32_t access;
			std::uint32_t flags;
			std::uint64_t object;

			std::wstring type_name;
			std::wstring name;

			std::shared_ptr<section_info> section;
		};

		/// <summary>
		/// Query the handle table of this process.
		/// </summary>
		/// <returns>
		/// If this function succeeds, the return value is a vector containing all the process handles.
		/// <para/>
		/// If this function fails, the return value is an empty vector.
		/// </returns>
		std::vector<system_handle> const handle_table() const noexcept
		{
			NTSTATUS NtDuplicateObject(HANDLE, HANDLE, HANDLE, PHANDLE, ACCESS_MASK, ULONG, ULONG);
			DWORD NtQuerySection(HANDLE, SECTION_INFORMATION_CLASS, PVOID, ULONG, PULONG);

			static auto ntdll{ GetModuleHandleA(__mixin_xor_string("ntdll")) };
			if (ntdll == nullptr && (ntdll = GetModuleHandleA(__mixin_xor_string("ntdll"))) == nullptr)
			{
				return {};
			}

			unsigned long buffer_size{ 0x10000 };
			unsigned long size{};
			auto buffer{ VirtualAlloc(nullptr, buffer_size, MEM_COMMIT, PAGE_READWRITE) };
			NTSTATUS status{ native(NtQuerySystemInformation)(static_cast<SYSTEM_INFORMATION_CLASS>(16), buffer, buffer_size, &size) };
			while (status == 0xC0000004L /*STATUS_INFO_LENGTH_MISMATCH*/)
			{
				buffer_size *= 2;
				VirtualFree(buffer, 0, MEM_RELEASE);
				buffer = VirtualAlloc(nullptr, buffer_size, MEM_COMMIT, PAGE_READWRITE);
				status = native(NtQuerySystemInformation)(static_cast<SYSTEM_INFORMATION_CLASS>(16), buffer, buffer_size, &size);
			}

			if (!NT_SUCCESS(status))
			{
				VirtualFree(buffer, 0, MEM_RELEASE);
				return {};
			}

			std::vector<system_handle> handles{};
			auto handle_information{ reinterpret_cast<SYSTEM_HANDLE_INFORMATION_T*>(buffer) };
			for (index i{}; i < handle_information->HandleCount; i++)
			{
				auto handle{ handle_information->Handles[i] };
				if (handle.ProcessId != _id) { continue; }

				process_handle local_handle;
				status = native(NtDuplicateObject)(this->handle(), reinterpret_cast<HANDLE>(handle.Handle), GetCurrentProcess(), &local_handle, 0, 0, DUPLICATE_SAME_ACCESS);
				if (!NT_SUCCESS(status)) { break; }

				auto type_info{ reinterpret_cast<OBJECT_TYPE_INFORMATION_T*>(new char[0x1000]) };
				status = native(NtQueryObject)(local_handle, OBJECT_INFORMATION_CLASS::ObjectTypeInformation, type_info, 0x1000, nullptr);
				if (!NT_SUCCESS(status)) { continue; }

				auto name_info{ new char[0x1000] };
				status = native(NtQueryObject)(local_handle, static_cast<OBJECT_INFORMATION_CLASS>(1), name_info, 0x1000, &size);
				if (!NT_SUCCESS(status))
				{
					delete[] name_info;
					name_info = new char[size];
					status = native(NtQueryObject)(local_handle, static_cast<OBJECT_INFORMATION_CLASS>(1), name_info, size, nullptr);
					if (!NT_SUCCESS(status))
					{
						delete[] type_info;
						delete[] name_info;
						continue;
					}
				}

				auto object_name{ *reinterpret_cast<PUNICODE_STRING>(name_info) };

				system_handle handle_info{};
				handle_info.handle = reinterpret_cast<HANDLE>(handle.Handle);
				handle_info.access = handle.GrantedAccess;
				handle_info.flags = handle.Object;

				if (type_info->Name.Length) { handle_info.type_name = reinterpret_cast<wchar_t*>(type_info->Name.Buffer); }
				if (object_name.Length) { handle_info.name = object_name.Buffer; }

				if (handle_info.type_name.compare(__mixin_xor_string(L"Section")) == 0)
				{
					SECTION_BASIC_INFORMATION_T section{};
					status = native(NtQuerySection)(local_handle, SECTION_INFORMATION_CLASS::SectionBasicInformation, &section, sizeof(section), nullptr);
					if (NT_SUCCESS(status)) { handle_info.section = std::make_shared<system_handle::section_info>(); }

					handle_info.section->size = section.Size.QuadPart;
					handle_info.section->attribute = section.Attributes;
				}

				handles.emplace_back(handle_info);

				delete[] type_info;
				delete[] name_info;
			}

			VirtualFree(buffer, 0, MEM_RELEASE);
			return handles;
		}

		/// <summary>
		/// Gets all threads of this process.
		/// </summary>
		/// <returns>
		/// If this function succeeds, the return value is a vector containing all threads of the process.
		/// <para/>
		/// If this function fails, the return value is an empty vector.
		/// </returns>
		std::vector<thread> const threads() const noexcept
		{
			mixins::handle snapshot{ CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, _id) };
			if (!snapshot) { return {}; }

			THREADENTRY32 entry{ sizeof(entry) };
			if (!Thread32First(snapshot, &entry)) { return {}; }

			std::vector<thread> threads{};
			do
			{
				if (entry.th32OwnerProcessID != _id) { continue; }

				thread thread{};
				thread._id = entry.th32ThreadID;
				threads.emplace_back(std::move(thread));
			} while (Thread32Next(snapshot, &entry));

			return threads;
		}

		/// <summary>
		/// Gets all modules of this process.
		/// </summary>
		/// <returns>
		/// If this function succeeds, the return value is a vector containing all modules of the process.
		/// <para/>
		/// If this function fails, the return value is an empty vector.
		/// </returns>
		std::vector<module> const modules() const noexcept
		{
			mixins::handle snapshot{ CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, _id) };
			if (!snapshot) { return{}; }

			std::vector<module> modules;

			tagMODULEENTRY32 entry{ sizeof(entry) };
			if constexpr (std::is_same_v<char_type, char>)
			{
				if (!Module32First(snapshot, &entry)) { return {}; }

				do
				{
					if (entry.th32ProcessID != _id) { continue; }

					basic_process::module module{};
					module._base_address = entry.modBaseAddr;
					module._handle = entry.hModule;
					module._module_name = entry.szExePath;
					module._name = entry.szModule;
					module._size = entry.modBaseSize;
					modules.emplace_back(module);
				} while (Module32Next(snapshot, &entry));
			}
			else
			{
				if (!Module32FirstW(snapshot, &entry)) { return {}; }

				do
				{
					if (entry.th32ProcessID != _id) { continue; }

					basic_process::module module{};
					module._base_address = entry.modBaseAddr;
					module._handle = entry.hModule;
					module._module_name = entry.szExePath;
					module._name = entry.szModule;
					module._size = entry.modBaseSize;
					modules.emplace_back(module);
				} while (Module32NextW(snapshot, &entry));
			}

			return modules;
		}

		/// <summary>
		/// Reserves, commits, or changes the state of a region of memory within the virtual address space of a specified process. The function initializes the memory it allocates to zero.
		/// </summary>
		/// <param name="size">The size of the region of memory to allocate, in bytes. the function rounds size up to the next page boundary. </param>
		/// <param name="allocation_type">The type of memory allocation.</param>
		/// <param name="protect">The memory protection for the region of pages to be allocated. If the pages are being committed, you can specify any one of the memory protection constants.</param>
		/// <returns>If the function succeeds, the return value is the base address of the allocated region of pages.
		/// <para/>
		/// If the function fails, the return value is nullptr. To get extended error information, call GetLastError.
		/// </returns>
		__mixin_forceinline inline memory allocate(std::size_t size, unsigned long allocation_type = MEM_COMMIT, unsigned long protect = PAGE_EXECUTE_READWRITE)
		{
			memory memory{};
			memory._base_address = memory._allocation_base = VirtualAllocEx(handle(), nullptr, size, allocation_type, protect);
			memory._allocation_protect = protect;
			memory._size = size;
			memory._state = allocation_type;
			return memory;
		}

		/// <summary>
		/// Reserves, commits, or changes the state of a region of memory within the virtual address space of a specified process. The function initializes the memory it allocates to zero.
		/// </summary>
		/// <param name="base_address"> The pointer that specifies a desired starting address for the region of pages that you want to allocate.
		///  If you are reserving memory, the function rounds this address down to the nearest multiple of the allocation granularity.
		///  If you are committing memory that is already reserved, the function rounds this address down to the nearest page boundary.
		///  To determine the size of a page and the allocation granularity on the host computer, use the GetSystemInfo function.
		///  If base_address is unllptr, the function determines where to allocate the region.
		///  If this address is within an enclave that you have not initialized by calling InitializeEnclave,
		///  VirtualAllocEx allocates a page of zeros for the enclave at that address. The page must be previously uncommitted,
		///  and will not be measured with the EEXTEND instruction of the Intel Software Guard Extensions programming model.
		///	 If the address in within an enclave that you initialized, then the allocation operation fails with the ERROR_INVALID_ADDRESS error.
		/// </param>
		/// <param name="size">The size of the region of memory to allocate, in bytes.
		/// If base_address is nullptr, the function rounds size up to the next page boundary.
		/// If base_address is not nullptr, the function allocates all pages that contain one or more bytes in the range from base_address to base_address+size.
		/// This means, for example, that a 2-byte range that straddles a page boundary causes the function to allocate both pages.
		/// </param>
		/// <param name="allocation_type">The type of memory allocation.</param>
		/// <param name="protect">The memory protection for the region of pages to be allocated. If the pages are being committed, you can specify any one of the memory protection constants.</param>
		/// <returns>
		///	If the function succeeds, the return value is the base address of the allocated region of pages.
		/// <para/>
		///	If the function fails, the return value is NULL.To get extended error information, call GetLastError.
		/// </returns>
		__mixin_forceinline inline memory allocate(void* base_address, std::size_t size, unsigned long allocation_type = MEM_COMMIT, unsigned long protect = PAGE_EXECUTE_READWRITE)
		{
			memory memory{};
			memory._allocation_base = base_address;
			memory._base_address = VirtualAllocEx(handle(), base_address, size, allocation_type, protect);
			memory._size = size;
			memory._allocation_protect = protect;
			memory._state = allocation_type;
			return memory;
		}
	};

	/// <summary>
	/// Provides access to local processes and enables you to start and stop local system processes.
	/// </summary>
	using process = basic_process<char>;

	/// <summary>
	/// Provides access to local processes and enables you to start and stop local system processes.
	/// </summary>
	using wprocess = basic_process<wchar_t>;

	/// <summary>
	/// Verify that the current Windows version is equal to or greater than the specified version.
	/// </summary>
	/// <param name="major">Major version.</param>
	/// <param name="minor">Minor version.</param>
	/// <param name="service_pack_major">Service pack major version.</param>
	/// <returns>
	/// Returns true if the current Windows version is equal to or greater than the specified version.
	/// </returns>
	__mixin_forceinline inline bool is_windows_version_or_greater(std::uint16_t major, std::uint16_t minor, std::uint16_t service_pack_major) noexcept
	{
		OSVERSIONINFOEXW version_info{ sizeof(version_info), 0, 0, 0, 0, {}, 0, 0 };
		std::uint64_t const condition_mask = VerSetConditionMask(VerSetConditionMask(VerSetConditionMask(0, VER_MAJORVERSION,
			VER_GREATER_EQUAL), VER_MINORVERSION, VER_GREATER_EQUAL), VER_SERVICEPACKMAJOR, VER_GREATER_EQUAL);

		version_info.dwMajorVersion = major;
		version_info.dwMinorVersion = minor;
		version_info.wServicePackMajor = service_pack_major;

		return VerifyVersionInfoW(&version_info, VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR, condition_mask) != FALSE;
	}

	/// <summary>
	/// Verify that the current Windows version is equal to or lesser than the specified version.
	/// </summary>
	/// <param name="major">Major version.</param>
	/// <param name="minor">Minor version.</param>
	/// <param name="service_pack_major">Service pack major version.</param>
	/// <returns>
	/// Returns true if the current Windows version is equal to or lesser than the specified version.
	/// </returns>
	__mixin_forceinline inline bool is_windows_version_or_lesser(std::uint16_t major, std::uint16_t minor, std::uint16_t service_pack_major) noexcept
	{
		OSVERSIONINFOEXW version_info{ sizeof(version_info), 0, 0, 0, 0, { 0 }, 0, 0 };
		std::uint64_t const condition_mask{ VerSetConditionMask(VerSetConditionMask(0, VER_MAJORVERSION, VER_EQUAL), VER_MINORVERSION,
			VER_LESS_EQUAL) };

		version_info.dwMajorVersion = major;
		version_info.dwMinorVersion = minor;
		version_info.wServicePackMajor = service_pack_major;

		return VerifyVersionInfoW(&version_info, VER_MAJORVERSION | VER_MINORVERSION, condition_mask);
	}

	__mixin_forceinline inline bool is_windows_xp_or_greater() { return is_windows_version_or_greater(HIBYTE(_WIN32_WINNT_WINXP), LOBYTE(_WIN32_WINNT_WINXP), 0); }
	__mixin_forceinline inline bool is_windows_xp_sp1_or_greater() { return is_windows_version_or_greater(HIBYTE(_WIN32_WINNT_WINXP), LOBYTE(_WIN32_WINNT_WINXP), 1); }
	__mixin_forceinline inline bool is_windows_xp_sp2_or_greater() { return is_windows_version_or_greater(HIBYTE(_WIN32_WINNT_WINXP), LOBYTE(_WIN32_WINNT_WINXP), 2); }
	__mixin_forceinline inline bool is_windows_xp_sp3_or_greater() { return is_windows_version_or_greater(HIBYTE(_WIN32_WINNT_WINXP), LOBYTE(_WIN32_WINNT_WINXP), 3); }
	__mixin_forceinline inline bool is_windows_vista_or_greater() { return is_windows_version_or_greater(HIBYTE(_WIN32_WINNT_VISTA), LOBYTE(_WIN32_WINNT_VISTA), 0); }
	__mixin_forceinline inline bool is_windows_vista_sp1_or_greater() { return is_windows_version_or_greater(HIBYTE(_WIN32_WINNT_VISTA), LOBYTE(_WIN32_WINNT_VISTA), 1); }
	__mixin_forceinline inline bool is_windows_vista_sp2_or_greater() { return is_windows_version_or_greater(HIBYTE(_WIN32_WINNT_VISTA), LOBYTE(_WIN32_WINNT_VISTA), 2); }
	__mixin_forceinline inline bool is_windows_7_or_greater() { return is_windows_version_or_greater(HIBYTE(_WIN32_WINNT_WIN7), LOBYTE(_WIN32_WINNT_WIN7), 0); }
	__mixin_forceinline inline bool is_windows_7sp1_or_greater() { return is_windows_version_or_greater(HIBYTE(_WIN32_WINNT_WIN7), LOBYTE(_WIN32_WINNT_WIN7), 1); }
	__mixin_forceinline inline bool is_windows_8_or_greater() { return is_windows_version_or_greater(HIBYTE(_WIN32_WINNT_WIN8), LOBYTE(_WIN32_WINNT_WIN8), 0); }
	__mixin_forceinline inline bool is_windows_81or_greater() { return is_windows_version_or_greater(HIBYTE(_WIN32_WINNT_WINBLUE), LOBYTE(_WIN32_WINNT_WINBLUE), 0); }
	__mixin_forceinline inline bool is_windows_10_or_greater() { return is_windows_version_or_greater(10, 0, 0); }
	__mixin_forceinline inline bool is_windows_xp_or_2k() { return is_windows_version_or_lesser(HIBYTE(_WIN32_WINNT_WINXP), LOBYTE(_WIN32_WINNT_WINXP), 0); }

	__mixin_forceinline inline bool is_windows_server()
	{
		OSVERSIONINFOEXW version_info = { sizeof(version_info), 0, 0, 0, 0, {0}, 0, 0, 0, VER_NT_WORKSTATION };
		std::uint64_t const condition_mask = VerSetConditionMask(0, VER_PRODUCT_TYPE, VER_EQUAL);
		return !VerifyVersionInfoW(&version_info, VER_PRODUCT_TYPE, condition_mask);
	}

	#ifdef _M_X64
	inline bool detect_debugger() noexcept
	{
		//
		// Calling LoadLibrary increments the reference count.
		//
		auto ntdll{ LoadLibraryA(__mixin_xor_string("ntdll")) };
		auto kernel32{ LoadLibraryA(__mixin_xor_string("kernel32")) };

		//
		// Determine whether current process is being debugged by a user-mode debugger.
		// If the current process is running in the context of a debugger, the return value is nonzero.
		//
		if (IsDebuggerPresent())
		{
			return true;
		}

		//
		// The IsDebuggerPresent function is actually a wrapper around this code.
		//
		if (reinterpret_cast<PPEB>(__readgsqword(0x60))->BeingDebugged)
		{
			return true;
		}

		bool debugger_present{};

		//
		// It can be used to check a remote process is being debugged,
		// However, we can also use this for checking if our own process is being debugged.
		// It calls the ntdll export NtQueryInformationProcess with the SYSTEM_INFORMATION_CLASS set to 7 (ProcessDebugPort).
		//
		CheckRemoteDebuggerPresent(GetCurrentProcess(), reinterpret_cast<PBOOL>(&debugger_present));
		if (debugger_present)
		{
			return true;
		}

		//
		// NtGlobalFlag is a unsigned value inside the process PEB. It contains many flags set by the OS
		// that affects the way the process runs. When a process is being debugged, the flags
		// FLG_HEAP_ENABLE_TAIL_CHECK (0x10), FLG_HEAP_ENABLE_FREE_CHECK(0x20), and FLG_HEAP_VALIDATE_PARAMETERS(0x40)
		// are set for the process, and we can use this to ouradvantage to identify if our process is being debugged.
		//
		auto nt_global_flag{ reinterpret_cast<unsigned*>(__readgsqword(0x60) + 0xBC) };

		//
		// 0x70 =  FLG_HEAP_ENABLE_TAIL_CHECK | FLG_HEAP_ENABLE_FREE_CHECK | FLG_HEAP_VALIDATE_PARAMETERS
		//
		if (nt_global_flag && *nt_global_flag & 0x00000070)
		{
			return true;
		}

		unsigned* heap{};

		//
		// When a process is run under a debugger, and is created using the debug process creation flags. The heap flags are changed.
		// These Flags exit at a different location depending upon the version of the operating system.
		// On Windows XP, these flags exist at 0x0C offset from heap base in 32bit system and offset 0x14 in 64bits.
		// On Windows 7, these flags exist at 0x40 offset from heap base in 32bit system and offset 0x70 in 64bits.
		//
		if (is_windows_vista_or_greater())
		{
			auto process_heap{ reinterpret_cast<std::int64_t*>(__readgsqword(0x60) + 0x30) };
			heap = reinterpret_cast<unsigned*>(*process_heap + 0x70);
		}
		else
		{
			auto process_heap{ reinterpret_cast<std::int64_t*>(__readgsqword(0x60) + 0x30) };
			heap = reinterpret_cast<unsigned*>(*process_heap + 0x14);
		}

		if (*heap > 2)
		{
			return true;
		}

		unsigned* heap_force_flags{};

		//
		// When a process is run under a debugger, and is created using the debug process creation flags. The heap flags are changed.
		// These Flags exit at a different location depending upon the version of the operating system.
		// On Windows XP, these flags exist at 0x10 offset from heap base in 32bit system and offset 0x18 in bits.
		// On Windows 7, these flags exist at 0x44 offset from heap base in 32bit system and offset 0x74 in 64bits.
		//
		//
		if (is_windows_vista_or_greater())
		{
			auto process_heap{ reinterpret_cast<std::int64_t*>(__readgsqword(0x60) + 0x30) };
			heap_force_flags = reinterpret_cast<unsigned*>(*process_heap + 0x74);
		}
		else
		{
			auto process_heap{ reinterpret_cast<std::int64_t*>(__readgsqword(0x60) + 0x30) };
			heap_force_flags = reinterpret_cast<unsigned*>(*process_heap + 0x18);
		}

		if (*heap_force_flags > 0)
		{
			return true;
		}

		std::uint64_t is_remote_present{};

		//
		// Instead of calling CheckRemoteDebuggerPresent an individual could also directly the call to 
		// NtQueryInformationProcess process theirself.
		//
		auto status{ native(NtQueryInformationProcess)(GetCurrentProcess(), static_cast<PROCESSINFOCLASS>(7),
			&is_remote_present, static_cast<unsigned long>(sizeof(is_remote_present)), nullptr) };
		if (NT_SUCCESS(status) && is_remote_present) { return true; }

		std::uint32_t no_debug_inherit{};

		//
		// Calling NtQeuryInformationProcess with ProcessDebugFlags as the class gets the inverse of EPROCESS->NoDebugInherit.
		// Which means that if a debugger is present, then the function will return false if the process is being debugged.
		//
		status = native(NtQueryInformationProcess)(GetCurrentProcess(), static_cast<PROCESSINFOCLASS>(0x1F), &no_debug_inherit,
			static_cast<unsigned long>(sizeof(no_debug_inherit)), nullptr);
		if (NT_SUCCESS(status) && no_debug_inherit == 0) { return true; }

		HANDLE debug_object{};

		//
		// This function uses NtQuerySystemInformation to try to retrieve a handle to the current process's debug object handle.
		// If the function is successful it'll return true which means we're being debugged or it'll return false if it fails
		// the process isn't being debugged
		//
		status = native(NtQueryInformationProcess)(GetCurrentProcess(), static_cast<PROCESSINFOCLASS>(0x1E), &debug_object,
			static_cast<unsigned long>(sizeof(debug_object)), nullptr);
		if (NT_SUCCESS(status) && debug_object) { return true; }

		bool thread_hidden{};

		//
		// Calling NtSetInformationThread will attempt with ThreadInformationClass set to 0x11 (ThreadHideFromDebugger)
		// to hide a thread from the debugger, Passing null for handle of thread will cause the function to hide the thread the
		// function is running in. Also the function returns false on failure and true on success. When the function
		// is called, the thread will continue to run but a debugger will no longer receive any events related to that thread.
		//

		//
		// Issuing a bogus call with an incorrect length parameter. If it succeeds, NtSetInformationThread may be hooked.
		//
		status = native(NtSetInformationThread)(GetCurrentThread(), static_cast<THREADINFOCLASS>(0x11), &thread_hidden, 12345);
		if (NT_SUCCESS(status))
		{
			return true;
		}

		//
		// Next try again but give it a bogus handle thread. If it succeeds, NtSetInformationThread may be hooked.
		//
		status = native(NtSetInformationThread)(reinterpret_cast<HANDLE>(0xFFFF), static_cast<THREADINFOCLASS>(0x11), nullptr, 0);
		if (NT_SUCCESS(status)) { return true; }

		//
		// No hooks detected, try a legitimate call.
		//
		status = native(NtSetInformationThread)(GetCurrentThread(), static_cast<THREADINFOCLASS>(0x11), nullptr, 0);
		if (NT_SUCCESS(status))
		{

			//
			// Only do the NtQueryInformationThread check if we're on Vista or higher and the api is available.
			// ThreadHideFromDebugger class can only be quired from Vista onwards.
			//
			if (is_windows_vista_or_greater())
			{
				status = native(NtQueryInformationThread)(GetCurrentThread(), static_cast<THREADINFOCLASS>(0x11), &thread_hidden,
					static_cast<unsigned long>(sizeof(int)), nullptr);
				if (NT_SUCCESS(status))
				{
					if (!thread_hidden)
					{

						//
						// If thread isn't hidden, it means that the ThreadHideFromDebugger call didn't worked.
						//
						return true;
					}
				}
				else
				{

					//
					// Call failed, should've succeeded.
					//
					return true;
				}
			}
		}

		__try
		{

			//
			// APIs making user of the ZwClose syscall (such as CloseHandle, indirectly)
			// can be used to detect a debugger. When a process is debugged, calling ZwClose
			// with an invalid handle will generate a STATUS_INVALID_HANDLE (0xC0000008) exception.
			// As with all anti-debugs that rely on information made directly available.
			//
			CloseHandle(reinterpret_cast<HANDLE>(0x99999999ULL));
		}
		__except (EXCEPTION_EXECUTE_HANDLER)
		{
			return true;
		}

		__try
		{

			//
			// Direct call to NtClose to bypass user mode hooks.
			//
			native(NtClose)(reinterpret_cast<HANDLE>(0x99999999ULL));
		}
		__except (EXCEPTION_EXECUTE_HANDLER)
		{
			return true;
		}

		static bool is_beging_debugged{ true };
		auto top{ SetUnhandledExceptionFilter([](auto) -> long
		{

			//
			// If a debugger is present, then this function will not be reached.
			//
			is_beging_debugged = false;
			return EXCEPTION_CONTINUE_EXECUTION;
		}) };

		//
		// When an exception occurs, and no registered Exception Handlers exist (neither Structed nor Vectored),
		// or if none of the registered handlers the exception, then the kernel32 UnhandledExceptionFilter
		// function will be called as a last resort.
		//
		RaiseException(EXCEPTION_FLT_DIVIDE_BY_ZERO, 0, 0, nullptr);
		SetUnhandledExceptionFilter(top);
		if (is_beging_debugged)
		{
			return true;
		}

		if (is_windows_xp_or_2k())
		{
			SetLastError(0x29A);

			//
			// OutputDebugString is typically used to output a string value to the debugging data stream.
			// This string is then displayed in the debugger. Due to this fact, the function OutputDebugString
			// acts differently based on the existence of a debugger on the running process. If a debugger is
			// attached to the process, the function will execute normally and no error state will be registered;
			// however if there is no debugger attached, LastError will be set by the process letting us know that
			// we are debugger free. To execute this method we set LastError to an arbitrary value of our choosing
			// and then call OutputDebugString. We then check GetLastError and if our error code remains,
			// we know we are debugger free. This Works only in Windows XP/2000.
			//
			OutputDebugStringA(__mixin_xor_string("Mixin Debugger-Detector"));
			if (GetLastError() == 0x29A)
			{
				return true;
			}
		}

		is_beging_debugged = true;
		auto handler{ AddVectoredExceptionHandler(1, [](auto info) -> long
		{
			is_beging_debugged = false;
			if (info->ExceptionRecord->ExceptionCode == EXCEPTION_BREAKPOINT)
			{
				info->ContextRecord->Rip++;
				return EXCEPTION_CONTINUE_EXECUTION;
			}

			return EXCEPTION_CONTINUE_SEARCH;
		}) };
		if (handler == nullptr) { return true; }
		__debugbreak();
		RemoveVectoredExceptionHandler(handler);
		if (is_beging_debugged) { return true; }

		typedef struct _ALK_PROCESS_BASIC_INFORMATION
		{
			PVOID Reserved1;
			void* PebBaseAddress;
			PVOID Reserved2[2];
			ULONG_PTR UniqueProcessId;
			ULONG_PTR ParentProcessId;
		} ALK_PROCESS_BASIC_INFORMATION;

		ALK_PROCESS_BASIC_INFORMATION process_basic_information{};
		native(NtQueryInformationProcess)(GetCurrentProcess(), PROCESSINFOCLASS::ProcessBasicInformation,
			&process_basic_information, static_cast<unsigned long>(sizeof(ALK_PROCESS_BASIC_INFORMATION)), nullptr);

		unsigned long parent_process_id{};
		GetWindowThreadProcessId(GetShellWindow(), &parent_process_id);

		if (process_basic_information.ParentProcessId != parent_process_id) { return true; }

		unsigned long __stdcall CsrGetProcessId();

		auto csrss{ OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION,false, native(CsrGetProcessId)()) };
		if (csrss)
		{
			CloseHandle(csrss);
			return true;
		}

		#define DEBUG_READ_EVENT 0x0001
		#define DEBUG_PROCESS_ASSIGN 0x0002
		#define DEBUG_SET_INFORMATION 0x0004
		#define DEBUG_QUERY_INFORMATION 0x0008
		#define DEBUG_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | \
				DEBUG_READ_EVENT | DEBUG_PROCESS_ASSIGN | DEBUG_SET_INFORMATION | \
				DEBUG_QUERY_INFORMATION)

		NTSTATUS __stdcall NtCreateDebugObject(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, ULONG);

		HANDLE debug_object_handle{};
		OBJECT_ATTRIBUTES attributes{};
		InitializeObjectAttributes(&attributes, 0, 0, 0, 0);
		native(NtCreateDebugObject)(&debug_object_handle, DEBUG_ALL_ACCESS, &attributes, false);

		typedef struct _OBJECT_TYPE_INFORMATION
		{
			UNICODE_STRING TypeName;
			ULONG TotalNumberOfHandles;
			ULONG TotalNumberOfObjects;
		}OBJECT_TYPE_INFORMATION, * POBJECT_TYPE_INFORMATION;

		POBJECT_TYPE_INFORMATION object_information = reinterpret_cast<POBJECT_TYPE_INFORMATION>(new char[0x1000]);
		status = native(NtQueryObject)(debug_object_handle, OBJECT_INFORMATION_CLASS::ObjectTypeInformation, object_information, 0x1000, nullptr);
		CloseHandle(debug_object_handle);

		if (NT_SUCCESS(status) && object_information->TotalNumberOfObjects == 0) { return true; }

		delete[] object_information;

		unsigned long size{};
		native(NtQueryObject)(static_cast<HANDLE>(nullptr), static_cast<OBJECT_INFORMATION_CLASS>(3), &size, static_cast<unsigned long>(sizeof(unsigned)), &size);

		auto allocation{ VirtualAlloc(nullptr, size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE) };
		if (allocation == nullptr) { return true; }

		status = native(NtQueryObject)(reinterpret_cast<HANDLE>(-1), static_cast<OBJECT_INFORMATION_CLASS>(3), allocation, size, nullptr);
		if (NT_SUCCESS(status))
		{
			typedef struct _OBJECT_ALL_INFORMATION
			{
				ULONG NumberOfObjects;
				OBJECT_TYPE_INFORMATION ObjectTypeInformation[1];
			}OBJECT_ALL_INFORMATION, * POBJECT_ALL_INFORMATION;

			auto object_info{ reinterpret_cast<POBJECT_ALL_INFORMATION>(allocation) };
			auto pointer{ reinterpret_cast<unsigned char*>(static_cast<std::uint64_t>(object_info->NumberOfObjects)) };
			auto number_of_objects{ object_info->NumberOfObjects };
			for (unsigned i{}; i < number_of_objects; i++)
			{
				auto object_type_info{ reinterpret_cast<POBJECT_TYPE_INFORMATION>(pointer) };
				if (std::char_traits<wchar_t>::compare(__mixin_xor_string(L"DebugObject"), object_type_info->TypeName.Buffer,
					std::char_traits<wchar_t>::length(__mixin_xor_string(L"DebugObject")) == 0))
				{
					if (object_type_info->TotalNumberOfObjects > 0)
					{
						VirtualFree(allocation, 0, MEM_RELEASE);
						return true;
					}
					else
					{
						break;
					}
				}

				pointer = reinterpret_cast<unsigned char*>(object_type_info->TypeName.Buffer);
				pointer += object_type_info->TypeName.MaximumLength;

				auto location{ reinterpret_cast<std::uint64_t>(pointer) & -static_cast<std::int64_t>(sizeof(void*)) };
				if (location != reinterpret_cast<std::uint64_t>(pointer)) { location += sizeof(void*); }

				pointer = reinterpret_cast<unsigned char*>(location);
			}
		}

		VirtualFree(allocation, 0, MEM_RELEASE);

		NTSTATUS __stdcall NtYieldExecution();

		int debugger_count{};

		for (int i{}; i < 0x20; i++)
		{
			std::this_thread::sleep_for(0xFms);
			if (native(NtYieldExecution)() != 0x40000024) { debugger_count++; }
		}

		if (debugger_count > 3) { return true; }

		auto mutex{ CreateMutexA(nullptr, false, __mixin_xor_string("Mixin Debugger-Detector")) };
		SetHandleInformation(mutex, HANDLE_FLAG_PROTECT_FROM_CLOSE, HANDLE_FLAG_PROTECT_FROM_CLOSE);

		__try
		{
			CloseHandle(mutex);
		}
		__except (EXCEPTION_EXECUTE_HANDLER)
		{
			return true;
		}

		typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION
		{
			BOOLEAN KernelDebuggerEnabled;
			BOOLEAN KernelDebuggerNotPresent;
		} SYSTEM_KERNEL_DEBUGGER_INFORMATION, * PSYSTEM_KERNEL_DEBUGGER_INFORMATION;

		SYSTEM_KERNEL_DEBUGGER_INFORMATION debugger_info{};
		status = native(NtQuerySystemInformation)(static_cast<SYSTEM_INFORMATION_CLASS>(0x23), &debugger_info,
			static_cast<unsigned long>(sizeof(SYSTEM_KERNEL_DEBUGGER_INFORMATION)), nullptr);
		if (NT_SUCCESS(status))
		{
			if (debugger_info.KernelDebuggerEnabled || !debugger_info.KernelDebuggerNotPresent) { return true; }
		}

		auto const user_shared_data{ 0x7FFE0000 };
		auto const debugger_enabled_bytes{ *reinterpret_cast<unsigned char*>(user_shared_data + 0x2D4) };
		bool const kernel_debugger_enabled{ (debugger_enabled_bytes & 0x1) == 0x1 };
		bool const kernel_debugger_not_present{ (debugger_enabled_bytes & 0x2) == 0 };

		if (kernel_debugger_enabled || !kernel_debugger_not_present) { return true; }

		if (ntdll) { FreeLibrary(ntdll); }
		if (kernel32) { FreeLibrary(kernel32); }

		return false;
	}
	#endif

	/// <summary>
	/// <para>Basic Settings Manager.</para>
	/// Allocate a new file for each setting.
	/// </summary>
	template<character char_type = typename mixins::char_type>
	class basic_setting_manager
	{
	private:
		std::string_view _directory;
	public:

		/// <summary>
		/// Initialize the setting manager with the parameter "directory" to automatically remove all directory separators at the end
		/// </summary>
		/// <param name="directory">The directory where the settings file is stored</param>
		basic_setting_manager(std::basic_string_view<char_type> const& directory = "") : _directory{ directory }
		{
			while (_directory.ends_with("\\"))
			{
				_directory = _directory.substr(_directory.size() - 1);
			}

			std::filesystem::create_directories(_directory);
		}

		/// <summary>
		/// Read a setting.
		/// </summary>
		/// <typeparam name="T">Type of the setting.</typeparam>
		/// <param name="name">Value of the setting.</param>
		/// <returns></returns>
		template<typename T>
		inline T read(std::basic_string_view<char_type> name) noexcept
		{
			static std::allocator<T> allocator;
			T& value = *allocator.allocate(1);

			std::fstream stream;
			if constexpr (std::is_same_v<char_type, char>)
			{
				stream.open(connect<char_type>(_directory.data(), "\\", name.data()));
			}
			else
			{
				stream.open(connect<char_type>(_directory.data(), L"\\", name.data()));
			}

			stream >> value;

			return value;
		}

		/// <summary>
		/// Write a setting.
		/// </summary>
		/// <typeparam name="T">Type of the setting.</typeparam>
		/// <param name="name">Name of the setting.</param>
		/// <param name="value">Value of the setting.</param>
		/// <returns></returns>
		template<typename T>
		inline void write(std::basic_string_view<char_type> name, T const& value) noexcept
		{
			std::fstream stream;
			if constexpr (std::is_same_v<char_type, char>)
			{
				stream.open(connect<char_type>(_directory.data(), "\\", name.data()).data(), std::ios::out);
			}
			else
			{
				stream.open(connect<char_type>(_directory.data(), L"\\", name.data()).data(), std::ios::out);
			}

			stream << value;
		}
	};

	/// <summary>
	/// <para>Basic Settings Manager.</para>
	/// Allocate a new file for each setting.
	/// </summary>
	using setting_manager = basic_setting_manager<char>;

	/// <summary>
	/// <para>Basic Settings Manager.</para>
	/// Allocate a new file for each setting.
	/// </summary>
	using wsetting_manager = basic_setting_manager<wchar_t>;

	/// <summary>
	/// Brings down the system in a controlled manner.
	/// <para>Generate system BugCheck needs to get shutdown privilege, this function will get this privilege automatically.</para>
	/// </summary>
	/// <param name="code">Error code</param>
	__mixin_forceinline [[noreturn]] inline void bug_check(std::uint32_t code) noexcept
	{
		NTSTATUS __stdcall RtlAdjustPrivilege(ULONG Privilege, BOOLEAN Enable, BOOLEAN CurrentThread, PBOOLEAN Enabled);
		NTSTATUS __stdcall ZwRaiseHardError(std::uint32_t, std::uint32_t, std::uint32_t, std::uint32_t, std::uint32_t, std::uint32_t*);

		BOOLEAN enabled{};
		native(RtlAdjustPrivilege)(0x13, true, false, &enabled);

		std::uint32_t response{};
		native(ZwRaiseHardError)(code, 0, 0, 0, 6, &response);
	}

	__mixin_forceinline inline int _Lde(void* pointer, int d) noexcept
	{
		constexpr unsigned char lde_shell_code[12800]
		{
			0x55, 0x48, 0x83, 0xEC, 0x2B, 0x48, 0x89, 0xE5, 0x51, 0x52, 0x56, 0xE8, 0x00, 0x21, 0x00, 0x00,
			0xEF, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE7, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xDF, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD7, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xE5, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xED, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE5, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xAF, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA7, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x9F, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x97, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xA5, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xAD, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xBF, 0x2A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x6F, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x5F, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x57, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x65, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x6D, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x2F, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x1F, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x25, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x2D, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xEF, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE7, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xDF, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD7, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xE5, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x98, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE5, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xAF, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA7, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x9F, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x97, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xA5, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x58, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA5, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x6F, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x5F, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x57, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x65, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x18, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x2F, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x1F, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x25, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xD8, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x97, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8F, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x87, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x77, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6F, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x67, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5F, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x28, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x18, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x08, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xF8, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x80, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x70, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x60, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x50, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x40, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x30, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x20, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x10, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x16, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD7, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xA8, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xDF, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xFD, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xB5, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xA0, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x90, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x85, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7D, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x75, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6D, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x65, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5D, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x55, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4D, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x45, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3D, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x35, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2D, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x25, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1D, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x15, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x5E, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x68, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xCF, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xBF, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB7, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xAF, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA7, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x9F, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x97, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x8F, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x7F, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAE, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x80, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x70, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x60, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x50, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x40, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xF1, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x20, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x10, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x55, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5F, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x45, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4F, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xE0, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD8, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xD0, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC8, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xC5, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE6, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xB0, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA8, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xA0, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x90, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x85, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7D, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x75, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6D, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x65, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5D, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x55, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4D, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x80, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x70, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x60, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x50, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x5E, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x56, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x3F, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE8, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x06, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x2E, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB4, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xDA, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB8, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xFF, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA8, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xA0, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9D, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xAD, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x6F, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x5F, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x57, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x68, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x50, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xF2, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xB5, 0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x8A, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD6, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x3A, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x05, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFD, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xF5, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xED, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xE5, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xDD, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xD5, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCD, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xEE, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE6, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xB8, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAD, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xA0, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x90, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x48, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xE7, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x60, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xFB, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x40, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x30, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x20, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x5D, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x91, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAB, 0x1D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xDF, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD7, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x4D, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD8, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xD0, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC8, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xC0, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB8, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x1D, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA8, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x0D, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x90, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF5, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x6F, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x5F, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x57, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x4F, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x3F, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xDC, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x1F, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x0F, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xFF, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF7, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x38, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x28, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x4D, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x3D, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xAF, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA7, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x9F, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x97, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x8F, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x7F, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x80, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x70, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x60, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xBD, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB5, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xA0, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA5, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xB9, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x8D, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x7D, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xEF, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE7, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xDF, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD7, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xCF, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xBF, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB7, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xAF, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA7, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x9F, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x97, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x8F, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x7F, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x6F, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x5F, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x57, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x4F, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x3F, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x2F, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x1F, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x0F, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xFF, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF7, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xEF, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE7, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xDF, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD7, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xCF, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xBF, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB7, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xAF, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA7, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x9F, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x97, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xAB, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA3, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x7F, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x6F, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7D, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x01, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x4F, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x3F, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x2F, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x9D, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x0F, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xFF, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF7, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x2E, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x10, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xFE, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF6, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xEE, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE6, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xDE, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD6, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xCE, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xBE, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB6, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x6F, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x5F, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x57, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x4F, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x3F, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x2F, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x1F, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x0F, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xFF, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF7, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xF0, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD7, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x3E, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x3D, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xC0, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB8, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xB0, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x97, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xFE, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x66, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x6F, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x5F, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x57, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x4F, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x3F, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x2F, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xB5, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x0F, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xFF, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF7, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xEF, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE7, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xDF, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD7, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xCF, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xBF, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6F, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xC0, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB8, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xB0, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA8, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xA0, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x90, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x6F, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x5F, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x57, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x4F, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xE7, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x2F, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x1F, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x0F, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xFF, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF7, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xEF, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE7, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xDF, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD7, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xCF, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x67, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB7, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xAF, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA7, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x9F, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x97, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x8F, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x7F, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xDB, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x5F, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x57, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x4F, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x3F, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x2F, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x1F, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x0F, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xFF, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xEF, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE7, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xDF, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD7, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xCF, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xBF, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB7, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xAF, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA7, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x9F, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x97, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x0D, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xFD, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF5, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x8B, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE5, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xDD, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD5, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x6B, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xBD, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x53, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xAD, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA5, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x9D, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x0F, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xFF, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x0B, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xFB, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF3, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xEB, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE3, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x3D, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xCB, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC3, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xBB, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB3, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x0D, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xFD, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF5, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x8B, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x7B, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x73, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x6B, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xBD, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x53, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x4B, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x3B, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x2B, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x1B, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x0B, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x5D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x4D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x3D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x2D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x1D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x0D, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xFD, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF5, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xED, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE5, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xDD, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD5, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xCD, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC5, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xBD, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB5, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xAD, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA5, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x9D, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x8D, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x7D, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x6D, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x5D, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x4D, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x3D, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x2D, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x1D, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x0D, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xFD, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF5, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xED, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE5, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xDD, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD5, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xCD, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC5, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xBD, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB5, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xAD, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA5, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x9D, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x8D, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x7D, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x6D, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x5D, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x4D, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x3D, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x2D, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x1D, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x0D, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xFD, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF5, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xED, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE5, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xDD, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD5, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xCD, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC5, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xBD, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB5, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xAD, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA5, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x9D, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x8D, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x7D, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x6D, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x5D, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x4D, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x3D, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x2D, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x1D, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x0D, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xFD, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF5, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xED, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE5, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xDD, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD5, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xCD, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC5, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xBD, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB5, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xAD, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA5, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x9D, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x8D, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x7D, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x6D, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x5D, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x4D, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x3D, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x2D, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x1D, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x0D, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xFD, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF5, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xED, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE5, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xDD, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD5, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xCD, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC5, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xBD, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB5, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xAD, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA5, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x9D, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x8D, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x7D, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x6D, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x5D, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x4D, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x3D, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x2D, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x1D, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x0D, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xFD, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF5, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x05, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFD, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xDD, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD5, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xCD, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC5, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xBD, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB5, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xAD, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA5, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x9D, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x8D, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x7D, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x6D, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x5D, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x4D, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x3D, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xCB, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC3, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xBB, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB3, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xAB, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA3, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x9B, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xED, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE5, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xDD, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD5, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x6B, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x5B, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x53, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xAD, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA5, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x9D, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x8D, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x7D, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x0B, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xFB, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x4D, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x3D, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x2D, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x1D, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x0D, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xFD, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF5, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xED, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE5, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xDD, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD5, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xCD, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC5, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xBD, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB5, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xAD, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA5, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x9D, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x8D, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x7D, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x0B, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xFB, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x4D, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x3D, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x2D, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x1D, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x0D, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xFD, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF5, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xED, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE5, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xDD, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD5, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xCD, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC5, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xBD, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB5, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xAD, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA5, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x9D, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x8D, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x7D, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x0B, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xFB, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF3, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x4D, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x3D, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x2D, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x1D, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x0D, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xFD, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF5, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xED, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE5, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xDD, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD5, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xCD, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC5, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xBD, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB5, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xAD, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA5, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x9D, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x8D, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x7D, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x6D, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x5D, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x4D, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x3D, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x2D, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x1D, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x0D, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xFD, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF5, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xED, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE5, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xDD, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD5, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xCD, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC5, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xBD, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB5, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xAD, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA5, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x9D, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x8D, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x7D, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x6D, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x5D, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x4D, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x3D, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x2D, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x1D, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x0D, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xFD, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF5, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xED, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE5, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xDD, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD5, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xCD, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC5, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xBD, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB5, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xAD, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA5, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x9D, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x8D, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x7D, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x6D, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x5D, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x4D, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x3D, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x2D, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x1D, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x0D, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xFD, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF5, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xED, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE5, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xDD, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD5, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xCD, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC5, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xBD, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB5, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xAD, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA5, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x9D, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x8D, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x7D, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x6D, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x5D, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x4D, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x3D, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x2D, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x1D, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x0D, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xFD, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF5, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xED, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE5, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xDD, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD5, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xCD, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC5, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xBD, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB5, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xAD, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA5, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x9D, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x8D, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x7D, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xAC, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA4, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x9C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x94, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x8D, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xB3, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x74, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x6C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x5C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x4D, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x3C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x2C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x1C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x0D, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xEC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xCC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xBC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x5E, 0x51, 0x8F, 0x45, 0x23, 0x89, 0x55, 0x1E, 0xC6, 0x45, 0x22, 0x00, 0xC7, 0x45, 0x02, 0x20,
			0x00, 0x00, 0x00, 0xC7, 0x45, 0x06, 0x20, 0x00, 0x00, 0x00, 0x83, 0x7D, 0x1E, 0x40, 0x75, 0x07,
			0xC7, 0x45, 0x06, 0x40, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x45, 0x23, 0x48, 0x0F, 0xB6, 0x08, 0x48,
			0x8D, 0x04, 0xCE, 0x48, 0x03, 0x00, 0xFF, 0xD0, 0x5E, 0x5A, 0x59, 0x48, 0x83, 0xF8, 0xFF, 0x74,
			0x07, 0x48, 0x8B, 0x45, 0x23, 0x48, 0x29, 0xC8, 0x48, 0x83, 0xC4, 0x2B, 0x5D, 0xC3, 0xC7, 0x45,
			0x1A, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x45, 0x23, 0x0F, 0xB6, 0x40, 0x01, 0x25, 0xC7, 0x00,
			0x00, 0x00, 0xB9, 0x40, 0x00, 0x00, 0x00, 0x48, 0x31, 0xD2, 0xF7, 0xF1, 0x89, 0x45, 0x0A, 0x83,
			0xF8, 0x01, 0x75, 0x04, 0x83, 0x45, 0x1A, 0x01, 0x83, 0xF8, 0x02, 0x75, 0x04, 0x83, 0x45, 0x1A,
			0x04, 0x89, 0x55, 0x0E, 0xC1, 0xE0, 0x06, 0x48, 0x01, 0xF0, 0x48, 0x05, 0x00, 0x20, 0x00, 0x00,
			0x48, 0x8D, 0x04, 0xD0, 0x48, 0x03, 0x00, 0xFF, 0xD0, 0xC3, 0x48, 0x8B, 0x45, 0x23, 0x0F, 0xB6,
			0x40, 0x01, 0x83, 0xE0, 0x38, 0xC1, 0xE8, 0x03, 0x89, 0x45, 0x16, 0xC3, 0xC3, 0x83, 0x7D, 0x06,
			0x20, 0x7C, 0x23, 0x83, 0x45, 0x1A, 0x01, 0x48, 0x8B, 0x45, 0x23, 0x0F, 0xB6, 0x40, 0x02, 0x83,
			0xE0, 0x07, 0x89, 0x45, 0x12, 0x83, 0x7D, 0x12, 0x05, 0x75, 0x0A, 0x83, 0x7D, 0x0A, 0x00, 0x75,
			0x04, 0x83, 0x45, 0x1A, 0x04, 0xC3, 0xC3, 0x83, 0x7D, 0x06, 0x20, 0x7C, 0x05, 0x83, 0x45, 0x1A,
			0x04, 0xC3, 0xC3, 0x83, 0x7D, 0x06, 0x10, 0x75, 0x05, 0x83, 0x45, 0x1A, 0x02, 0xC3, 0xC3, 0xE8,
			0x5A, 0xFF, 0xFF, 0xFF, 0x8B, 0x45, 0x1A, 0x01, 0x45, 0x23, 0x48, 0x83, 0x45, 0x23, 0x02, 0xC3,
			0x48, 0xFF, 0x45, 0x23, 0xC3, 0x48, 0x83, 0x45, 0x23, 0x02, 0xC3, 0x83, 0x7D, 0x02, 0x10, 0x75,
			0x06, 0xE8, 0xD9, 0xFF, 0xFF, 0xFF, 0xC3, 0xE8, 0x51, 0x02, 0x00, 0x00, 0xC3, 0x83, 0x7D, 0x1E,
			0x40, 0x75, 0x06, 0xE8, 0x45, 0x02, 0x00, 0x00, 0xC3, 0x48, 0xFF, 0x45, 0x23, 0xC3, 0x83, 0x7D,
			0x02, 0x20, 0x7C, 0x06, 0x48, 0x83, 0x45, 0x23, 0x05, 0xC3, 0x48, 0x83, 0x45, 0x23, 0x03, 0xC3,
			0x83, 0x7D, 0x02, 0x40, 0x75, 0x06, 0x48, 0x83, 0x45, 0x23, 0x09, 0xC3, 0x83, 0x7D, 0x02, 0x20,
			0x75, 0x06, 0x48, 0x83, 0x45, 0x23, 0x05, 0xC3, 0x48, 0x83, 0x45, 0x23, 0x03, 0xC3, 0xE8, 0x8C,
			0xFF, 0xFF, 0xFF, 0x48, 0xFF, 0x45, 0x23, 0xC3, 0x83, 0x7D, 0x1E, 0x40, 0x75, 0x24, 0xC7, 0x45,
			0x02, 0x40, 0x00, 0x00, 0x00, 0x48, 0xFF, 0x45, 0x23, 0x48, 0x8B, 0x45, 0x23, 0x48, 0x0F, 0xB6,
			0x08, 0x48, 0x8D, 0x04, 0xCE, 0x48, 0x03, 0x00, 0xFF, 0xD0, 0xC7, 0x45, 0x02, 0x20, 0x00, 0x00,
			0x00, 0xC3, 0x48, 0xFF, 0x45, 0x23, 0xC3, 0x83, 0x7D, 0x1E, 0x40, 0x75, 0x25, 0x48, 0xFF, 0x45,
			0x23, 0xFE, 0x45, 0x22, 0x80, 0x7D, 0x22, 0x0F, 0x75, 0x06, 0xE8, 0xBE, 0x01, 0x00, 0x00, 0xC3,
			0x48, 0x8B, 0x45, 0x23, 0x48, 0x0F, 0xB6, 0x08, 0x48, 0x8D, 0x04, 0xCE, 0x48, 0x03, 0x00, 0xFF,
			0xD0, 0xC3, 0x48, 0x83, 0x45, 0x23, 0x01, 0xC3, 0xFF, 0x45, 0x23, 0xFE, 0x45, 0x22, 0x80, 0x7D,
			0x22, 0x0F, 0x75, 0x06, 0xE8, 0x94, 0x01, 0x00, 0x00, 0xC3, 0x48, 0x8B, 0x45, 0x23, 0x48, 0x0F,
			0xB6, 0x08, 0x48, 0x8D, 0x04, 0xCE, 0x48, 0x03, 0x00, 0xFF, 0xD0, 0xC3, 0x83, 0x7D, 0x02, 0x20,
			0x7C, 0x0B, 0xE8, 0xF8, 0xFE, 0xFF, 0xFF, 0x48, 0x83, 0x45, 0x23, 0x04, 0xC3, 0xE8, 0xED, 0xFE,
			0xFF, 0xFF, 0x48, 0x83, 0x45, 0x23, 0x02, 0xC3, 0x83, 0x7D, 0x1E, 0x40, 0x75, 0x06, 0xE8, 0x5A,
			0x01, 0x00, 0x00, 0xC3, 0x48, 0x83, 0x45, 0x23, 0x02, 0xC3, 0x48, 0x83, 0x45, 0x23, 0x04, 0xC3,
			0x48, 0x83, 0x45, 0x23, 0x05, 0xC3, 0x83, 0x7D, 0x1E, 0x40, 0x75, 0x06, 0xE8, 0x3C, 0x01, 0x00,
			0x00, 0xC3, 0xE8, 0xB8, 0xFE, 0xFF, 0xFF, 0xC3, 0xE8, 0x11, 0xFE, 0xFF, 0xFF, 0x83, 0x7D, 0x0A,
			0x03, 0x75, 0x06, 0xE8, 0xA7, 0xFE, 0xFF, 0xFF, 0xC3, 0xE8, 0x1F, 0x01, 0x00, 0x00, 0xC3, 0x48,
			0x83, 0x45, 0x23, 0x03, 0xC3, 0x83, 0x7D, 0x06, 0x40, 0x75, 0x06, 0x48, 0x83, 0x45, 0x23, 0x09,
			0xC3, 0x48, 0x83, 0x45, 0x23, 0x05, 0xC3, 0x83, 0x7D, 0x06, 0x10, 0x75, 0x06, 0x48, 0x83, 0x45,
			0x23, 0x03, 0xC3, 0x83, 0x7D, 0x06, 0x20, 0x75, 0x06, 0x48, 0x83, 0x45, 0x23, 0x05, 0xC3, 0x48,
			0x83, 0x45, 0x23, 0x09, 0xC3, 0x80, 0x7D, 0x00, 0x01, 0x75, 0x06, 0xE8, 0x5F, 0xFE, 0xFF, 0xFF,
			0xC3, 0xE8, 0xD7, 0x00, 0x00, 0x00, 0xC3, 0x80, 0x7D, 0x00, 0x01, 0x75, 0x06, 0xE8, 0x4D, 0xFE,
			0xFF, 0xFF, 0xC3, 0x80, 0x7D, 0x01, 0x01, 0x75, 0x06, 0xE8, 0x41, 0xFE, 0xFF, 0xFF, 0xC3, 0x83,
			0x7D, 0x02, 0x10, 0x75, 0x06, 0xE8, 0x35, 0xFE, 0xFF, 0xFF, 0xC3, 0xE8, 0xAD, 0x00, 0x00, 0x00,
			0xC3, 0x83, 0x7D, 0x1E, 0x40, 0x75, 0x06, 0xE8, 0xA1, 0x00, 0x00, 0x00, 0xC3, 0x83, 0x7D, 0x02,
			0x20, 0x75, 0x06, 0x48, 0x83, 0x45, 0x23, 0x07, 0xC3, 0x48, 0x83, 0x45, 0x23, 0x05, 0xC3, 0xC3,
			0x83, 0x7D, 0x02, 0x10, 0x74, 0x11, 0xE8, 0x63, 0xFD, 0xFF, 0xFF, 0x8B, 0x45, 0x1A, 0x01, 0x45,
			0x23, 0x48, 0x83, 0x45, 0x23, 0x06, 0xC3, 0xE8, 0x52, 0xFD, 0xFF, 0xFF, 0x8B, 0x45, 0x1A, 0x01,
			0x45, 0x23, 0x48, 0x83, 0x45, 0x23, 0x04, 0xC3, 0x83, 0x7D, 0x1E, 0x40, 0x75, 0x06, 0xE8, 0x5A,
			0x00, 0x00, 0x00, 0xC3, 0x83, 0x7D, 0x02, 0x20, 0x75, 0x06, 0x48, 0x83, 0x45, 0x23, 0x07, 0xC3,
			0x48, 0x83, 0x45, 0x23, 0x05, 0xC3, 0xE8, 0x6F, 0xFD, 0xFF, 0xFF, 0x83, 0x7D, 0x16, 0x00, 0x75,
			0x06, 0xE8, 0xB9, 0xFD, 0xFF, 0xFF, 0xC3, 0xE8, 0x31, 0x00, 0x00, 0x00, 0xC3, 0x83, 0x7D, 0x1E,
			0x40, 0x75, 0x06, 0x48, 0x83, 0x45, 0x23, 0x05, 0xC3, 0x83, 0x7D, 0x02, 0x20, 0x75, 0x06, 0x48,
			0x83, 0x45, 0x23, 0x05, 0xC3, 0x48, 0x83, 0x45, 0x23, 0x03, 0xC3, 0x80, 0x7D, 0x00, 0x01, 0x75,
			0x06, 0xE8, 0x89, 0xFD, 0xFF, 0xFF, 0xC3, 0xE8, 0x01, 0x00, 0x00, 0x00, 0xC3, 0x48, 0xB8, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x1E, 0x40, 0x75, 0x06, 0xE8, 0xEA,
			0xFF, 0xFF, 0xFF, 0xC3, 0xE8, 0x66, 0xFD, 0xFF, 0xFF, 0x48, 0x83, 0x45, 0x23, 0x01, 0xC3, 0x83,
			0x7D, 0x02, 0x20, 0x7C, 0x0B, 0xE8, 0x55, 0xFD, 0xFF, 0xFF, 0x48, 0x83, 0x45, 0x23, 0x04, 0xC3,
			0xE8, 0x4A, 0xFD, 0xFF, 0xFF, 0x48, 0x83, 0x45, 0x23, 0x02, 0xC3, 0xE8, 0x9E, 0xFC, 0xFF, 0xFF,
			0xE8, 0xE5, 0xFC, 0xFF, 0xFF, 0x83, 0x7D, 0x16, 0x00, 0x75, 0x0C, 0x8B, 0x45, 0x1A, 0x01, 0x45,
			0x23, 0x48, 0x83, 0x45, 0x23, 0x03, 0xC3, 0x83, 0x7D, 0x16, 0x01, 0x75, 0x06, 0xE8, 0x9B, 0xFF,
			0xFF, 0xFF, 0xC3, 0x8B, 0x45, 0x1A, 0x01, 0x45, 0x23, 0x48, 0x83, 0x45, 0x23, 0x02, 0xC3, 0x83,
			0x7D, 0x02, 0x20, 0x7C, 0x34, 0xE8, 0x64, 0xFC, 0xFF, 0xFF, 0xE8, 0xAB, 0xFC, 0xFF, 0xFF, 0x83,
			0x7D, 0x16, 0x00, 0x75, 0x0C, 0x8B, 0x45, 0x1A, 0x01, 0x45, 0x23, 0x48, 0x83, 0x45, 0x23, 0x06,
			0xC3, 0x83, 0x7D, 0x16, 0x01, 0x75, 0x06, 0xE8, 0x61, 0xFF, 0xFF, 0xFF, 0xC3, 0x8B, 0x45, 0x1A,
			0x01, 0x45, 0x23, 0x48, 0x83, 0x45, 0x23, 0x02, 0xC3, 0xE8, 0x30, 0xFC, 0xFF, 0xFF, 0xE8, 0x77,
			0xFC, 0xFF, 0xFF, 0x83, 0x7D, 0x16, 0x00, 0x75, 0x0C, 0x8B, 0x45, 0x1A, 0x01, 0x45, 0x23, 0x48,
			0x83, 0x45, 0x23, 0x04, 0xC3, 0x83, 0x7D, 0x16, 0x01, 0x75, 0x06, 0xE8, 0x2D, 0xFF, 0xFF, 0xFF,
			0xC3, 0x8B, 0x45, 0x1A, 0x01, 0x45, 0x23, 0x48, 0x83, 0x45, 0x23, 0x02, 0xC3, 0xE8, 0xFC, 0xFB,
			0xFF, 0xFF, 0xE8, 0x43, 0xFC, 0xFF, 0xFF, 0x83, 0x7D, 0x16, 0x01, 0x7E, 0x06, 0xE8, 0x0B, 0xFF,
			0xFF, 0xFF, 0xC3, 0x8B, 0x45, 0x1A, 0x01, 0x45, 0x23, 0x48, 0x83, 0x45, 0x23, 0x02, 0xC3, 0xE8,
			0x26, 0xFC, 0xFF, 0xFF, 0x83, 0x7D, 0x16, 0x06, 0x7E, 0x06, 0xE8, 0xEE, 0xFE, 0xFF, 0xFF, 0xC3,
			0xE8, 0xC9, 0xFB, 0xFF, 0xFF, 0x8B, 0x45, 0x1A, 0x01, 0x45, 0x23, 0x48, 0x83, 0x45, 0x23, 0x02,
			0xC3, 0xE8, 0xB8, 0xFB, 0xFF, 0xFF, 0xE8, 0xFF, 0xFB, 0xFF, 0xFF, 0x83, 0x7D, 0x16, 0x05, 0x7E,
			0x06, 0xE8, 0xC7, 0xFE, 0xFF, 0xFF, 0xC3, 0x8B, 0x45, 0x1A, 0x01, 0x45, 0x23, 0x48, 0x83, 0x45,
			0x23, 0x02, 0xC3, 0xE8, 0x96, 0xFB, 0xFF, 0xFF, 0xE8, 0xDD, 0xFB, 0xFF, 0xFF, 0x83, 0x7D, 0x16,
			0x00, 0x75, 0x1A, 0x83, 0x7D, 0x0A, 0x03, 0x0F, 0x85, 0xAC, 0x00, 0x00, 0x00, 0x83, 0x7D, 0x0E,
			0x04, 0x0F, 0x8E, 0xA2, 0x00, 0x00, 0x00, 0xE8, 0x91, 0xFE, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16,
			0x01, 0x75, 0x1A, 0x83, 0x7D, 0x0A, 0x03, 0x0F, 0x85, 0x8C, 0x00, 0x00, 0x00, 0x83, 0x7D, 0x0E,
			0x01, 0x0F, 0x8E, 0x82, 0x00, 0x00, 0x00, 0xE8, 0x71, 0xFE, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16,
			0x02, 0x75, 0x10, 0x83, 0x7D, 0x0A, 0x03, 0x0F, 0x85, 0x6C, 0x00, 0x00, 0x00, 0xE8, 0x5B, 0xFE,
			0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x03, 0x75, 0x0C, 0x83, 0x7D, 0x0A, 0x03, 0x75, 0x5A, 0xE8,
			0x49, 0xFE, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x04, 0x75, 0x0C, 0x83, 0x7D, 0x0A, 0x03, 0x75,
			0x48, 0xE8, 0x37, 0xFE, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x05, 0x75, 0x06, 0xE8, 0x2B, 0xFE,
			0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x06, 0x75, 0x0C, 0x83, 0x7D, 0x0A, 0x03, 0x75, 0x2A, 0xE8,
			0x19, 0xFE, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x07, 0x75, 0x1E, 0x83, 0x7D, 0x0A, 0x03, 0x75,
			0x18, 0x83, 0x7D, 0x1E, 0x40, 0x75, 0x0C, 0x83, 0x7D, 0x0E, 0x00, 0x74, 0x0C, 0xE8, 0xFB, 0xFD,
			0xFF, 0xFF, 0xC3, 0xE8, 0xF5, 0xFD, 0xFF, 0xFF, 0xC3, 0x8B, 0x45, 0x1A, 0x01, 0x45, 0x23, 0x48,
			0x83, 0x45, 0x23, 0x02, 0xC3, 0xE8, 0xC4, 0xFA, 0xFF, 0xFF, 0xE8, 0x0B, 0xFB, 0xFF, 0xFF, 0x83,
			0x7D, 0x16, 0x04, 0x7D, 0x06, 0xE8, 0xD3, 0xFD, 0xFF, 0xFF, 0xC3, 0x8B, 0x45, 0x1A, 0x01, 0x45,
			0x23, 0x48, 0x83, 0x45, 0x23, 0x03, 0xC3, 0xE8, 0xA2, 0xFA, 0xFF, 0xFF, 0xE8, 0xE9, 0xFA, 0xFF,
			0xFF, 0x83, 0x7D, 0x16, 0x00, 0x75, 0x06, 0xE8, 0xB1, 0xFD, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16,
			0x02, 0x75, 0x06, 0xE8, 0xA5, 0xFD, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x03, 0x75, 0x06, 0xE8,
			0x99, 0xFD, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x04, 0x75, 0x06, 0xE8, 0x8D, 0xFD, 0xFF, 0xFF,
			0xC3, 0x83, 0x7D, 0x16, 0x05, 0x75, 0x06, 0xE8, 0x81, 0xFD, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16,
			0x07, 0x7E, 0x06, 0xE8, 0x75, 0xFD, 0xFF, 0xFF, 0xC3, 0x8B, 0x45, 0x1A, 0x01, 0x45, 0x23, 0x48,
			0x83, 0x45, 0x23, 0x02, 0xC3, 0xE8, 0x90, 0xFA, 0xFF, 0xFF, 0x83, 0x7D, 0x16, 0x00, 0x75, 0x06,
			0xE8, 0x58, 0xFD, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x01, 0x75, 0x06, 0xE8, 0x4C, 0xFD, 0xFF,
			0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x02, 0x75, 0x11, 0xE8, 0x21, 0xFA, 0xFF, 0xFF, 0x83, 0x7D, 0x0A,
			0x03, 0x74, 0x52, 0xE8, 0x35, 0xFD, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x03, 0x75, 0x06, 0xE8,
			0x29, 0xFD, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x04, 0x75, 0x11, 0xE8, 0xFE, 0xF9, 0xFF, 0xFF,
			0x83, 0x7D, 0x0A, 0x03, 0x74, 0x2F, 0xE8, 0x12, 0xFD, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x05,
			0x75, 0x06, 0xE8, 0x06, 0xFD, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x06, 0x75, 0x11, 0xE8, 0xDB,
			0xF9, 0xFF, 0xFF, 0x83, 0x7D, 0x0A, 0x03, 0x74, 0x0C, 0xE8, 0xEF, 0xFC, 0xFF, 0xFF, 0xC3, 0xE8,
			0xE9, 0xFC, 0xFF, 0xFF, 0xC3, 0x8B, 0x45, 0x1A, 0x01, 0x45, 0x23, 0x48, 0x83, 0x45, 0x23, 0x03,
			0xC3, 0xE8, 0x04, 0xFA, 0xFF, 0xFF, 0x83, 0x7D, 0x16, 0x00, 0x75, 0x06, 0xE8, 0xCC, 0xFC, 0xFF,
			0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x01, 0x75, 0x06, 0xE8, 0xC0, 0xFC, 0xFF, 0xFF, 0xC3, 0x83, 0x7D,
			0x16, 0x02, 0x75, 0x11, 0xE8, 0x95, 0xF9, 0xFF, 0xFF, 0x83, 0x7D, 0x0A, 0x03, 0x74, 0x52, 0xE8,
			0xA9, 0xFC, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x03, 0x75, 0x06, 0xE8, 0x9D, 0xFC, 0xFF, 0xFF,
			0xC3, 0x83, 0x7D, 0x16, 0x04, 0x75, 0x11, 0xE8, 0x72, 0xF9, 0xFF, 0xFF, 0x83, 0x7D, 0x0A, 0x03,
			0x74, 0x2F, 0xE8, 0x86, 0xFC, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x05, 0x75, 0x06, 0xE8, 0x7A,
			0xFC, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x06, 0x75, 0x11, 0xE8, 0x4F, 0xF9, 0xFF, 0xFF, 0x83,
			0x7D, 0x0A, 0x03, 0x74, 0x0C, 0xE8, 0x63, 0xFC, 0xFF, 0xFF, 0xC3, 0xE8, 0x5D, 0xFC, 0xFF, 0xFF,
			0xC3, 0x8B, 0x45, 0x1A, 0x01, 0x45, 0x23, 0x48, 0x83, 0x45, 0x23, 0x03, 0xC3, 0xE8, 0x78, 0xF9,
			0xFF, 0xFF, 0x83, 0x7D, 0x16, 0x00, 0x75, 0x06, 0xE8, 0x40, 0xFC, 0xFF, 0xFF, 0xC3, 0x83, 0x7D,
			0x16, 0x01, 0x75, 0x06, 0xE8, 0x34, 0xFC, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x02, 0x75, 0x15,
			0xE8, 0x09, 0xF9, 0xFF, 0xFF, 0x83, 0x7D, 0x0A, 0x03, 0x0F, 0x84, 0x7B, 0x00, 0x00, 0x00, 0xE8,
			0x19, 0xFC, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x03, 0x75, 0x1D, 0x83, 0x7D, 0x02, 0x10, 0x75,
			0x11, 0xE8, 0xE8, 0xF8, 0xFF, 0xFF, 0x83, 0x7D, 0x0A, 0x03, 0x74, 0x5E, 0xE8, 0xFC, 0xFB, 0xFF,
			0xFF, 0xC3, 0xE8, 0xF6, 0xFB, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x04, 0x75, 0x06, 0xE8, 0xEA,
			0xFB, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x05, 0x75, 0x06, 0xE8, 0xDE, 0xFB, 0xFF, 0xFF, 0xC3,
			0x83, 0x7D, 0x16, 0x06, 0x75, 0x11, 0xE8, 0xB3, 0xF8, 0xFF, 0xFF, 0x83, 0x7D, 0x0A, 0x03, 0x74,
			0x29, 0xE8, 0xC7, 0xFB, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x07, 0x75, 0x17, 0x83, 0x7D, 0x02,
			0x10, 0x75, 0x11, 0xE8, 0x96, 0xF8, 0xFF, 0xFF, 0x83, 0x7D, 0x0A, 0x03, 0x74, 0x0C, 0xE8, 0xAA,
			0xFB, 0xFF, 0xFF, 0xC3, 0xE8, 0xA4, 0xFB, 0xFF, 0xFF, 0xC3, 0x8B, 0x45, 0x1A, 0x01, 0x45, 0x23,
			0x48, 0x83, 0x45, 0x23, 0x03, 0xC3, 0xE8, 0xBF, 0xF8, 0xFF, 0xFF, 0x83, 0x7D, 0x16, 0x00, 0x75,
			0x15, 0xE8, 0x68, 0xF8, 0xFF, 0xFF, 0x83, 0x7D, 0x0A, 0x03, 0x0F, 0x85, 0xA0, 0x00, 0x00, 0x00,
			0xE8, 0x78, 0xFB, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x01, 0x75, 0x15, 0xE8, 0x4D, 0xF8, 0xFF,
			0xFF, 0x83, 0x7D, 0x0A, 0x03, 0x0F, 0x85, 0x85, 0x00, 0x00, 0x00, 0xE8, 0x5D, 0xFB, 0xFF, 0xFF,
			0xC3, 0x83, 0x7D, 0x16, 0x02, 0x75, 0x15, 0xE8, 0x32, 0xF8, 0xFF, 0xFF, 0x83, 0x7D, 0x0A, 0x03,
			0x0F, 0x85, 0x6A, 0x00, 0x00, 0x00, 0xE8, 0x42, 0xFB, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x03,
			0x75, 0x11, 0xE8, 0x17, 0xF8, 0xFF, 0xFF, 0x83, 0x7D, 0x0A, 0x03, 0x75, 0x53, 0xE8, 0x2B, 0xFB,
			0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x04, 0x75, 0x06, 0xE8, 0x1F, 0xFB, 0xFF, 0xFF, 0xC3, 0x83,
			0x7D, 0x16, 0x05, 0x75, 0x11, 0xE8, 0xF4, 0xF7, 0xFF, 0xFF, 0x83, 0x7D, 0x0A, 0x03, 0x75, 0x30,
			0xE8, 0x08, 0xFB, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x06, 0x75, 0x11, 0xE8, 0xDD, 0xF7, 0xFF,
			0xFF, 0x83, 0x7D, 0x0A, 0x03, 0x75, 0x19, 0xE8, 0xF1, 0xFA, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16,
			0x07, 0x7F, 0x07, 0xE8, 0xC6, 0xF7, 0xFF, 0xFF, 0xEB, 0x06, 0xE8, 0xDE, 0xFA, 0xFF, 0xFF, 0xC3,
			0x8B, 0x45, 0x1A, 0x01, 0x45, 0x23, 0x48, 0x83, 0x45, 0x23, 0x02, 0xC3, 0xE8, 0xF9, 0xF7, 0xFF,
			0xFF, 0x83, 0x7D, 0x16, 0x00, 0x75, 0x11, 0xE8, 0xA2, 0xF7, 0xFF, 0xFF, 0x83, 0x7D, 0x0A, 0x03,
			0x75, 0x51, 0xE8, 0xB6, 0xFA, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x01, 0x75, 0x11, 0xE8, 0x8B,
			0xF7, 0xFF, 0xFF, 0x83, 0x7D, 0x0A, 0x03, 0x75, 0x3A, 0xE8, 0x9F, 0xFA, 0xFF, 0xFF, 0xC3, 0x83,
			0x7D, 0x16, 0x02, 0x75, 0x11, 0xE8, 0x74, 0xF7, 0xFF, 0xFF, 0x83, 0x7D, 0x0A, 0x03, 0x75, 0x23,
			0xE8, 0x88, 0xFA, 0xFF, 0xFF, 0xC3, 0x83, 0x7D, 0x16, 0x03, 0x75, 0x11, 0xE8, 0x5D, 0xF7, 0xFF,
			0xFF, 0x83, 0x7D, 0x0A, 0x03, 0x75, 0x0C, 0xE8, 0x71, 0xFA, 0xFF, 0xFF, 0xC3, 0xE8, 0x6B, 0xFA,
			0xFF, 0xFF, 0xC3, 0x8B, 0x45, 0x1A, 0x01, 0x45, 0x23, 0x48, 0x83, 0x45, 0x23, 0x02, 0xC3, 0x48,
			0xFF, 0x45, 0x23, 0xC7, 0x45, 0x02, 0x10, 0x00, 0x00, 0x00, 0xFE, 0x45, 0x22, 0x80, 0x7D, 0x22,
			0x0F, 0x75, 0x06, 0xE8, 0x45, 0xFA, 0xFF, 0xFF, 0xC3, 0x48, 0x8B, 0x45, 0x23, 0x48, 0x0F, 0xB6,
			0x08, 0x48, 0x8D, 0x04, 0xCE, 0x48, 0x03, 0x00, 0xFF, 0xD0, 0xC7, 0x45, 0x02, 0x20, 0x00, 0x00,
			0x00, 0xC3, 0x48, 0xFF, 0x45, 0x23, 0xFE, 0x45, 0x22, 0x80, 0x7D, 0x22, 0x0F, 0x75, 0x06, 0xE8,
			0x19, 0xFA, 0xFF, 0xFF, 0xC3, 0x8B, 0x4D, 0x06, 0xD1, 0xE9, 0x89, 0x5D, 0x06, 0x48, 0x8B, 0x45,
			0x23, 0x48, 0x0F, 0xB6, 0x08, 0x48, 0x8D, 0x04, 0xCE, 0x48, 0x03, 0x00, 0xFF, 0xD0, 0x8B, 0x5D,
			0x06, 0xD1, 0xE1, 0x89, 0x4D, 0x06, 0xC3, 0x48, 0xFF, 0x45, 0x23, 0xFE, 0x45, 0x22, 0x80, 0x7D,
			0x22, 0x0F, 0x75, 0x06, 0xE8, 0xE4, 0xF9, 0xFF, 0xFF, 0xC3, 0x48, 0x8B, 0x45, 0x23, 0x0F, 0xB6,
			0x00, 0x3C, 0xA4, 0x74, 0x12, 0x3C, 0xA7, 0x74, 0x0E, 0x3C, 0xAE, 0x74, 0x0A, 0x3C, 0xAF, 0x74,
			0x06, 0x3C, 0x0F, 0x74, 0x02, 0xEB, 0x04, 0xC6, 0x45, 0x00, 0x01, 0x48, 0x8B, 0x45, 0x23, 0x48,
			0x0F, 0xB6, 0x08, 0x48, 0x8D, 0x04, 0xCE, 0x48, 0x03, 0x00, 0xFF, 0xD0, 0xC6, 0x45, 0x00, 0x00,
			0xC3, 0x48, 0xFF, 0x45, 0x23, 0xFE, 0x45, 0x22, 0x80, 0x7D, 0x22, 0x0F, 0x75, 0x06, 0xE8, 0x9A,
			0xF9, 0xFF, 0xFF, 0xC3, 0x48, 0x8B, 0x45, 0x23, 0x0F, 0xB6, 0x00, 0x3C, 0x90, 0x74, 0x3E, 0x3C,
			0xA4, 0x74, 0x3A, 0x3C, 0xA5, 0x74, 0x36, 0x3C, 0xA6, 0x74, 0x32, 0x3C, 0xA7, 0x74, 0x2E, 0x3C,
			0xAA, 0x74, 0x2A, 0x3C, 0xAB, 0x74, 0x26, 0x3C, 0xAC, 0x74, 0x22, 0x3C, 0xAD, 0x74, 0x1E, 0x3C,
			0xAE, 0x74, 0x1A, 0x3C, 0xAF, 0x74, 0x16, 0x3C, 0x6C, 0x74, 0x12, 0x3C, 0x6D, 0x74, 0x0E, 0x3C,
			0x6E, 0x74, 0x0A, 0x3C, 0x6F, 0x74, 0x06, 0x3C, 0x0F, 0x74, 0x02, 0xEB, 0x04, 0xC6, 0x45, 0x01,
			0x01, 0x48, 0x8B, 0x45, 0x23, 0x48, 0x0F, 0xB6, 0x08, 0x48, 0x8D, 0x04, 0xCE, 0x48, 0x03, 0x00,
			0xFF, 0xD0, 0xC6, 0x45, 0x01, 0x00, 0xC3, 0x48, 0xFF, 0x45, 0x23, 0xFE, 0x45, 0x22, 0x80, 0x7D,
			0x22, 0x0F, 0x75, 0x06, 0xE8, 0x24, 0xF9, 0xFF, 0xFF, 0xC3, 0x48, 0x8B, 0x45, 0x23, 0x48, 0x0F,
			0xB6, 0x08, 0x48, 0x8D, 0x84, 0xCE, 0x00, 0x08, 0x00, 0x00, 0x48, 0x03, 0x00, 0xFF, 0xD0, 0xC3,
			0x48, 0xFF, 0x45, 0x23, 0xFE, 0x45, 0x22, 0x80, 0x7D, 0x22, 0x0F, 0x75, 0x06, 0xE8, 0xFB, 0xF8,
			0xFF, 0xFF, 0xC3, 0x48, 0x8B, 0x45, 0x23, 0x48, 0x0F, 0xB6, 0x08, 0x48, 0x8D, 0x84, 0xCE, 0x00,
			0x10, 0x00, 0x00, 0x48, 0x03, 0x00, 0xFF, 0xD0, 0xC3, 0x48, 0xFF, 0x45, 0x23, 0xFE, 0x45, 0x22,
			0x80, 0x7D, 0x22, 0x0F, 0x75, 0x06, 0xE8, 0xD2, 0xF8, 0xFF, 0xFF, 0xC3, 0x48, 0x8B, 0x45, 0x23,
			0x48, 0x0F, 0xB6, 0x08, 0x48, 0x8D, 0x84, 0xCE, 0x00, 0x18, 0x00, 0x00, 0x48, 0x03, 0x00, 0xFF,
			0xD0, 0xC3, 0xC7, 0x45, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x45, 0x23, 0x0F, 0xB6, 0x40,
			0x01, 0x3D, 0xBF, 0x00, 0x00, 0x00, 0x7F, 0x11, 0xE8, 0xCD, 0xF5, 0xFF, 0xFF, 0x83, 0x7D, 0x16,
			0x07, 0x7E, 0x06, 0xE8, 0x95, 0xF8, 0xFF, 0xFF, 0xC3, 0xE8, 0x70, 0xF5, 0xFF, 0xFF, 0x8B, 0x45,
			0x1A, 0x01, 0x45, 0x23, 0x48, 0x83, 0x45, 0x23, 0x02, 0xC3, 0xC7, 0x45, 0x1A, 0x00, 0x00, 0x00,
			0x00, 0x48, 0x8B, 0x45, 0x23, 0x0F, 0xB6, 0x40, 0x01, 0x3D, 0xBF, 0x00, 0x00, 0x00, 0x7F, 0x17,
			0xE8, 0x95, 0xF5, 0xFF, 0xFF, 0x83, 0x7D, 0x16, 0x01, 0x75, 0x69, 0x83, 0x7D, 0x16, 0x07, 0x7E,
			0x63, 0xE8, 0x57, 0xF8, 0xFF, 0xFF, 0xC3, 0x3D, 0xC0, 0x00, 0x00, 0x00, 0x7C, 0x56, 0x89, 0xC2,
			0xC1, 0xEA, 0x04, 0x89, 0xC1, 0x83, 0xE1, 0x0F, 0x83, 0xFA, 0x0D, 0x75, 0x0B, 0x83, 0xF9, 0x00,
			0x74, 0x42, 0xE8, 0x36, 0xF8, 0xFF, 0xFF, 0xC3, 0x83, 0xFA, 0x0E, 0x75, 0x37, 0x83, 0xF9, 0x02,
			0x75, 0x06, 0xE8, 0x26, 0xF8, 0xFF, 0xFF, 0xC3, 0x83, 0xF9, 0x03, 0x75, 0x06, 0xE8, 0x1B, 0xF8,
			0xFF, 0xFF, 0xC3, 0x83, 0xF9, 0x06, 0x75, 0x06, 0xE8, 0x10, 0xF8, 0xFF, 0xFF, 0xC3, 0x83, 0xF9,
			0x07, 0x75, 0x06, 0xE8, 0x05, 0xF8, 0xFF, 0xFF, 0xC3, 0x83, 0xF9, 0x0F, 0x75, 0x06, 0xE8, 0xFA,
			0xF7, 0xFF, 0xFF, 0xC3, 0xE8, 0xD5, 0xF4, 0xFF, 0xFF, 0x8B, 0x45, 0x1A, 0x01, 0x45, 0x23, 0x48,
			0x83, 0x45, 0x23, 0x02, 0xC3, 0xC7, 0x45, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x45, 0x23,
			0x0F, 0xB6, 0x40, 0x01, 0x3D, 0xBF, 0x00, 0x00, 0x00, 0x7F, 0x11, 0xE8, 0xFA, 0xF4, 0xFF, 0xFF,
			0x83, 0x7D, 0x16, 0x07, 0x7E, 0x32, 0xE8, 0xC2, 0xF7, 0xFF, 0xFF, 0xC3, 0x3D, 0xC0, 0x00, 0x00,
			0x00, 0x7C, 0x25, 0x89, 0xC2, 0xC1, 0xEA, 0x04, 0x89, 0xC1, 0x83, 0xE1, 0x0F, 0x83, 0xFA, 0x0E,
			0x75, 0x0B, 0x83, 0xF9, 0x09, 0x74, 0x11, 0xE8, 0xA1, 0xF7, 0xFF, 0xFF, 0xC3, 0x83, 0xFA, 0x0F,
			0x75, 0x06, 0xE8, 0x96, 0xF7, 0xFF, 0xFF, 0xC3, 0xE8, 0x71, 0xF4, 0xFF, 0xFF, 0x8B, 0x45, 0x1A,
			0x01, 0x45, 0x23, 0x48, 0x83, 0x45, 0x23, 0x02, 0xC3, 0xC7, 0x45, 0x1A, 0x00, 0x00, 0x00, 0x00,
			0x48, 0x8B, 0x45, 0x23, 0x0F, 0xB6, 0x40, 0x01, 0x3D, 0xBF, 0x00, 0x00, 0x00, 0x7F, 0x1F, 0xE8,
			0x96, 0xF4, 0xFF, 0xFF, 0x83, 0x7D, 0x16, 0x04, 0x74, 0x0E, 0x83, 0x7D, 0x16, 0x06, 0x74, 0x08,
			0x83, 0x7D, 0x16, 0x07, 0x7F, 0x02, 0xEB, 0x41, 0xE8, 0x50, 0xF7, 0xFF, 0xFF, 0xC3, 0x3D, 0xC0,
			0x00, 0x00, 0x00, 0x7C, 0x34, 0x89, 0xC2, 0xC1, 0xEA, 0x04, 0x89, 0xC1, 0x83, 0xE1, 0x0F, 0x83,
			0xFA, 0x0E, 0x75, 0x15, 0x83, 0xF9, 0x08, 0x7D, 0x20, 0x83, 0xF9, 0x03, 0x74, 0x1B, 0x83, 0xF9,
			0x02, 0x74, 0x16, 0xE8, 0x25, 0xF7, 0xFF, 0xFF, 0xC3, 0x83, 0xFA, 0x0F, 0x75, 0x0B, 0x83, 0xF9,
			0x08, 0x7C, 0x06, 0xE8, 0x15, 0xF7, 0xFF, 0xFF, 0xC3, 0xE8, 0xF0, 0xF3, 0xFF, 0xFF, 0x8B, 0x45,
			0x1A, 0x01, 0x45, 0x23, 0x48, 0x83, 0x45, 0x23, 0x02, 0xC3, 0xC7, 0x45, 0x1A, 0x00, 0x00, 0x00,
			0x00, 0x48, 0x8B, 0x45, 0x23, 0x0F, 0xB6, 0x40, 0x01, 0x3D, 0xBF, 0x00, 0x00, 0x00, 0x7F, 0x11,
			0xE8, 0x15, 0xF4, 0xFF, 0xFF, 0x83, 0x7D, 0x16, 0x07, 0x7E, 0x22, 0xE8, 0xDD, 0xF6, 0xFF, 0xFF,
			0xC3, 0x3D, 0xC0, 0x00, 0x00, 0x00, 0x7C, 0x15, 0x89, 0xC2, 0xC1, 0xEA, 0x04, 0x89, 0xC1, 0x83,
			0xE1, 0x0F, 0x83, 0xFA, 0x0D, 0x75, 0x06, 0xE8, 0xC1, 0xF6, 0xFF, 0xFF, 0xC3, 0xE8, 0x9C, 0xF3,
			0xFF, 0xFF, 0x8B, 0x45, 0x1A, 0x01, 0x45, 0x23, 0x48, 0x83, 0x45, 0x23, 0x02, 0xC3, 0xC7, 0x45,
			0x1A, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x45, 0x23, 0x0F, 0xB6, 0x40, 0x01, 0x3D, 0xBF, 0x00,
			0x00, 0x00, 0x7F, 0x19, 0xE8, 0xC1, 0xF3, 0xFF, 0xFF, 0x83, 0x7D, 0x16, 0x05, 0x74, 0x08, 0x83,
			0x7D, 0x16, 0x07, 0x7F, 0x02, 0xEB, 0x32, 0xE8, 0x81, 0xF6, 0xFF, 0xFF, 0xC3, 0x3D, 0xC0, 0x00,
			0x00, 0x00, 0x7C, 0x25, 0x89, 0xC2, 0xC1, 0xEA, 0x04, 0x89, 0xC1, 0x83, 0xE1, 0x0F, 0x83, 0xFA,
			0x0C, 0x75, 0x0B, 0x83, 0xF9, 0x08, 0x7C, 0x11, 0xE8, 0x60, 0xF6, 0xFF, 0xFF, 0xC3, 0x83, 0xFA,
			0x0F, 0x75, 0x06, 0xE8, 0x55, 0xF6, 0xFF, 0xFF, 0xC3, 0xE8, 0x30, 0xF3, 0xFF, 0xFF, 0x8B, 0x45,
			0x1A, 0x01, 0x45, 0x23, 0x48, 0x83, 0x45, 0x23, 0x02, 0xC3, 0xC7, 0x45, 0x1A, 0x00, 0x00, 0x00,
			0x00, 0x48, 0x8B, 0x45, 0x23, 0x0F, 0xB6, 0x40, 0x01, 0x3D, 0xBF, 0x00, 0x00, 0x00, 0x7F, 0x11,
			0xE8, 0x55, 0xF3, 0xFF, 0xFF, 0x83, 0x7D, 0x16, 0x07, 0x7E, 0x27, 0xE8, 0x1D, 0xF6, 0xFF, 0xFF,
			0xC3, 0x3D, 0xC0, 0x00, 0x00, 0x00, 0x7C, 0x1A, 0x89, 0xC2, 0xC1, 0xEA, 0x04, 0x89, 0xC1, 0x83,
			0xE1, 0x0F, 0x83, 0xFA, 0x0D, 0x75, 0x0B, 0x83, 0xF9, 0x09, 0x74, 0x06, 0xE8, 0xFC, 0xF5, 0xFF,
			0xFF, 0xC3, 0xE8, 0xD7, 0xF2, 0xFF, 0xFF, 0x8B, 0x45, 0x1A, 0x01, 0x45, 0x23, 0x48, 0x83, 0x45,
			0x23, 0x02, 0xC3, 0xC7, 0x45, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x45, 0x23, 0x0F, 0xB6,
			0x40, 0x01, 0x3D, 0xBF, 0x00, 0x00, 0x00, 0x7F, 0x11, 0xE8, 0xFC, 0xF2, 0xFF, 0xFF, 0x83, 0x7D,
			0x16, 0x07, 0x7E, 0x52, 0xE8, 0xC4, 0xF5, 0xFF, 0xFF, 0xC3, 0x3D, 0xC0, 0x00, 0x00, 0x00, 0x7C,
			0x45, 0x89, 0xC2, 0xC1, 0xEA, 0x04, 0x89, 0xC1, 0x83, 0xE1, 0x0F, 0x83, 0xFA, 0x0C, 0x75, 0x06,
			0xE8, 0xA8, 0xF5, 0xFF, 0xFF, 0xC3, 0x83, 0xFA, 0x0D, 0x75, 0x06, 0xE8, 0x9D, 0xF5, 0xFF, 0xFF,
			0xC3, 0x83, 0xFA, 0x0E, 0x75, 0x10, 0x83, 0xF9, 0x00, 0x74, 0x1B, 0x83, 0xF9, 0x08, 0x7D, 0x16,
			0xE8, 0x88, 0xF5, 0xFF, 0xFF, 0xC3, 0x83, 0xFA, 0x0F, 0x75, 0x0B, 0x83, 0xF9, 0x08, 0x7C, 0x06,
			0xE8, 0x78, 0xF5, 0xFF, 0xFF, 0xC3, 0xE8, 0x53, 0xF2, 0xFF, 0xFF, 0x8B, 0x45, 0x1A, 0x01, 0x45,
			0x23, 0x48, 0x83, 0x45, 0x23, 0x02, 0xC3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
		};

		using lde_t = int(*)(void*, int);
		static lde_t lde{};
		if (lde == nullptr)
		{
			lde = reinterpret_cast<lde_t>(VirtualAlloc(nullptr, sizeof(lde_shell_code), MEM_COMMIT, PAGE_EXECUTE_READWRITE));
			memcpy(lde, lde_shell_code, sizeof(lde_shell_code));
		}

		if (lde == nullptr) { std::terminate(); }
		return lde(pointer, d);
	}

	__mixin_forceinline inline std::size_t _Get_patch_size(not_null<void*> address) noexcept
	{
		size_t length_count{}, length{};
		while (length_count < 14)
		{
			length = _Lde(address, 64);
			*reinterpret_cast<unsigned char**>(static_cast<void*>(address)) += length;
			length_count += length;
		}

		return length_count;
	}

	/// <summary>
	/// Initialize Mixin Service, if administrator privileges are required, a window displays and it automatically restarts with administrator privileges.
	/// </summary>
	/// <returns>If the function succeeds, the return value is true.</returns>
	template<typename = void>
	inline bool request_init_mixin() noexcept
	{
		#ifndef __mixin_link_comctl32__

		#else
		SetProcessDPIAware();

		if (!init_service())
		{
			SID_IDENTIFIER_AUTHORITY authority{ SECURITY_NT_AUTHORITY };
			PSID administrators_group{};
			if (!AllocateAndInitializeSid(&authority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
				0, 0, 0, 0, 0, 0, &administrators_group))
			{
				MessageBoxA(nullptr, mixins::last_error<char>().data(), nullptr, MB_ICONERROR);
				return 0;
			}

			bool result{};
			if (!CheckTokenMembership(nullptr, administrators_group, reinterpret_cast<int*>(&result)))
			{
				MessageBoxA(nullptr, mixins::last_error<char>().data(), nullptr, MB_ICONERROR);
				return 0;
			}

			FreeSid(administrators_group);

			if (result)
			{
				return false;
			}
			else
			{
				int button_pressed{};

				TASKDIALOG_BUTTON button[]{ {.nButtonID = 0,.pszButtonText = __mixin_xor_string(L"聞喘凪麿鴇象嶷仟尼強\n嶷仟尼強Mixin, 狼由氏戻幣艇厚個喘薩嬲薩。") },
					{.nButtonID = 1,.pszButtonText = __mixin_xor_string(L"函販暦旺卦指欺Mixin") } };

				TASKDIALOGCONFIG config{};
				config.dwFlags = _TASKDIALOG_FLAGS::TDF_ENABLE_HYPERLINKS | _TASKDIALOG_FLAGS::TDF_USE_COMMAND_LINKS | _TASKDIALOG_FLAGS::TDF_EXPAND_FOOTER_AREA;
				config.pButtons = button;
				config.cButtons = 2;
				config.pszMainInstruction = __mixin_xor_string(L"緩販暦勣箔哘喘殻會醤嗤戻幅議幡沺");
				config.pszWindowTitle = __mixin_xor_string(L"Heckerpowered Mixin");
				config.pszMainIcon = TD_SHIELD_ICON;
				auto last_error{ mixins::last_error<wchar_t>() };
				config.pszContent = last_error.data();
				config.dwCommonButtons = _TASKDIALOG_COMMON_BUTTON_FLAGS::TDCBF_CANCEL_BUTTON;
				config.pszExpandedControlText = __mixin_xor_string(L"臥心危列連");
				config.pszExpandedInformation = __mixin_xor_string(L"涙隈兜兵晒Mixin Service。Mixin Service短嗤怎校議蒙幡兜兵晒Mixin Service。勣兜兵晒Mixin Service, 駅倬參砿尖埀附芸塰佩Mixin。");
				config.cbSize = sizeof(config);
				config.hInstance = GetModuleHandleA(nullptr);

				TaskDialogIndirect(&config, &button_pressed, nullptr, nullptr);
				if (button_pressed == 0 && reinterpret_cast<std::uint64_t>(ShellExecuteA(GetDesktopWindow(), __mixin_xor_string("runas"), mixins::process::current().path().data(), nullptr,
					nullptr, SW_SHOW)) < 32)
				{
					return false;
				}

				std::terminate();
			}
		}
		else
		{
			return true;
		}
		#endif
	}

	/// <summary>
	/// Provides acess to local processor and enables you to query basic information of local processors.
	/// </summary>
	class processor
	{
	private:
		processor() = delete;
		~processor() = delete;

	public:

		static constexpr char const* features_name[] =
		{
			"SSE3 New Instructions",
			"MONITOR/MWAIT",
			"CPL Qualified Debug Store",
			"Thermal Monitor 2",
			"x87 FPU On Chip",
			"Virtual-8086 Mode Enhancement",
			"Debugging Extensions",
			"Page Size Extensions",
			"Time Stamp Counter",
			"RDMSR and WRMSR Support",
			"Physical Address Extensions",
			"Machine Check Exception",
			"CMPXCHG8B Instruction",
			"APIC On Chip",
			"Unknown1",
			"SYSENTER and SYSEXIT",
			"Memory Type Range Registers",
			"PTE Global Bit",
			"Machine Check Architecture",
			"Conditional Move/Compare Instruction",
			"Page Attribute Table",
			"Page Size Extension",
			"Processor Serial Number",
			"CFLUSH Extension",
			"Unknown2",
			"Debug Store",
			"Thermal Monitor and Clock Ctrl",
			"MMX Technology",
			"FXSAVE/FXRSTOR",
			"SSE Extensions",
			"SSE2 Extensions",
			"Self Snoop",
			"Hyper-threading Technology",
			"Thermal Monitor",
			"Unknown4",
			"Pend. Brk. EN."
		};

		enum class feature
		{
			/// <summary>
			/// SSE3 New Instructions
			/// </summary>
			sse3,

			/// <summary>
			/// MONITOR/MWAIT
			/// </summary>
			mmw,

			/// <summary>
			/// CPL Qualified Debug Store
			/// </summary>
			cqds,

			/// <summary>
			/// Thermal Monitor 2
			/// </summary>
			tm2,

			/// <summary>
			/// x87 FPU on Chip
			/// </summary>
			fpu,

			/// <summary>
			/// Virtual - 8086 Mode Enhancement
			/// </summary>
			vme,

			/// <summary>
			/// Debugging Extensions
			/// </summary>
			de,

			/// <summary>
			/// Page Size Extensions
			/// </summary>
			pse,

			/// <summary>
			/// Time Stamp Counter
			/// </summary>
			tsc,

			/// <summary>
			/// RDMSR and WRMSR Support
			/// </summary>
			msr,

			/// <summary>
			/// Physical Address Extensions
			/// </summary>
			pae,

			/// <summary>
			/// Machine Check Exception
			/// </summary>
			mce,

			/// <summary>
			/// CMPXCHG8B Inst
			/// </summary>
			cx8,

			/// <summary>
			/// APIC on Chip
			/// </summary>
			apic,

			/// <summary>
			/// Reserved
			/// </summary>
			na1,

			/// <summary>
			/// SYSENTER and SYSEXIT
			/// </summary>
			sep,

			/// <summary>
			/// Memory Type Range Registers
			/// </summary>
			mtrr,

			/// <summary>
			/// PTE Global Bit
			/// </summary>
			pge,

			/// <summary>
			/// Machine Check Architecture
			/// </summary>
			mca,

			/// <summary>
			/// Conditional Move/Compare Instruction
			/// </summary>
			cmov,

			/// <summary>
			/// Page Attribute Table
			/// </summary>
			pat,

			/// <summary>
			/// Page Size Extension
			/// </summary>
			pse2,

			/// <summary>
			/// Processor Serial Number
			/// </summary>
			psn,

			/// <summary>
			/// CFLUSH Instruction
			/// </summary>
			clfsh,

			/// <summary>
			/// Reserved
			/// </summary>
			na2,

			/// <summary>
			/// Debug Store
			/// </summary>
			ds,

			/// <summary>
			/// Thermal Monitor and Clock Ctrl
			/// </summary>
			acpi,

			/// <summary>
			/// MMX Technology
			/// </summary>
			mmx,

			/// <summary>
			/// FXSAVE/FXRSTOR
			/// </summary>
			fxsr,

			/// <summary>
			/// SSE Extensions
			/// </summary>
			sse,

			/// <summary>
			/// SSE2 Extensions
			/// </summary>
			sse2,

			/// <summary>
			/// Self Snoop
			/// </summary>
			ss,

			/// <summary>
			/// Hyper-threading technology
			/// </summary>
			htt,

			/// <summary>
			/// Thermal Monitor
			/// </summary>
			tm,

			/// <summary>
			/// Reserved.
			/// </summary>
			na3,

			/// <summary>
			/// Pend. Brk. En.
			/// </summary>
			pbe
		};

		/// <summary>
		/// Gets the local processors vendor.
		/// </summary>
		/// <returns>Example: "GenuineIntel"</returns>
		static std::string const& vendor() noexcept
		{
			static std::string vendor;

			if (!vendor.empty())
			{
				return vendor;
			}

			char data[0x20]{};
			int cpuid[4]{};

			//
			// Calling __cpuid with 0 as the InfoType argument gets the cpu string.
			//
			__cpuid(cpuid, 0);

			//
			// Interpret cpu string.
			//
			*reinterpret_cast<int*>(data) = cpuid[1];
			*reinterpret_cast<int*>(data + 4) = cpuid[3];
			*reinterpret_cast<int*>(data + 8) = cpuid[2];

			return vendor = data;
		}

		/// <summary>
		/// Gets the local processors brand.
		/// </summary>
		/// <returns>Example: "Genuine Intel(R) CPU 2.80GHz"</returns>
		static std::string const& brand() noexcept
		{
			static std::string brand;

			if (!brand.empty())
			{
				return brand;
			}

			char data[0x40]{};

			//
			// Calling __cpuid with 0x80000000 as the InfoType argument
			// gets the number of valid extended IDs.
			//
			int cpuid[4]{};
			__cpuid(cpuid, 0x80000000);
			unsigned extendedIDs(cpuid[0]);

			//
			// Get the information associated with each extended ID.
			//
			for (unsigned i{ 0x80000000 }; i <= extendedIDs; i++)
			{
				__cpuid(cpuid, i);

				//
				// Interpret CPU brand string and cache information.
				//
				if (i == 0x80000002)
				{
					memcpy(data, cpuid, sizeof(cpuid));
				}
				else if (i == 0x80000003)
				{
					memcpy(data + 16, cpuid, sizeof(cpuid));
				}
				else if (i == 0x80000004)
				{
					memcpy(data + 32, cpuid, sizeof(cpuid));
				}
			}

			return brand = data;
		}

		/// <summary>
		/// Gets all processor features.
		/// </summary>
		/// <returns></returns>
		static const std::map<feature, bool> features() noexcept
		{
			static std::map<feature, bool> features_map;
			if (!features_map.empty())
			{
				return features_map;
			}

			bool feature_sse3_new_instructions{};
			bool feature_monitor_mwait{};
			bool feature_cpl_quality_debug_store{};
			bool feature_thremal_monitor_2{};
			int feature_info_count{};

			int cpuid[4]{};

			//
			// __cpuid with an InfoType argument of 0 returns the number of
			// valid Ids in cpuid[0] and the cpu identification string in
			// the other three array elements. The CPU identification string is
			// not in linear order. The code below arranges the information
			// in a human readable form.
			//
			__cpuid(cpuid, 0);

			unsigned ids(cpuid[0]);
			for (unsigned i{}; i < ids; i++)
			{
				__cpuid(cpuid, i);

				//
				// Interpret CPU feature information.
				//
				if (i == 1)
				{
					feature_sse3_new_instructions = (cpuid[2] & 0x1);
					feature_monitor_mwait = (cpuid[2] & 0x8);
					feature_cpl_quality_debug_store = (cpuid[2] & 0x10);
					feature_thremal_monitor_2 = (cpuid[2] & 0x100);
					feature_info_count = cpuid[3];
				}
			}

			features_map.emplace(feature::sse3, feature_sse3_new_instructions);
			features_map.emplace(feature::mmw, feature_monitor_mwait);
			features_map.emplace(feature::cqds, feature_cpl_quality_debug_store);
			features_map.emplace(feature::tm2, feature_thremal_monitor_2);

			ids = 1;
			unsigned i{ 3 };
			while (i < (sizeof(features_name) / sizeof(char* const)))
			{
				features_map.emplace(static_cast<feature>(i), feature_info_count & (ids - 3));

				ids <<= (i - 3);
				i++;
			}

			return features_map;
		}

		template<feature feature>
		static std::string feature_name()
		{
			static std::string name = features_name[static_cast<int>(feature)];
			return name;
		}

		static std::string feature_name(feature feature)
		{
			return features_name[static_cast<int>(feature)];
		}
	};

	template<typename T, typename U>
	constexpr T&& cast(U&& u) noexcept
	{
		if constexpr (std::is_void_v<T>)
		{
			return;
		}

		if constexpr (static_castable<T, U>)
		{
			return static_cast<T&&>(u);
		}
		else if constexpr (reinterpret_castable<T, U>)
		{
			return reinterpret_cast<T&&>(u);
		}
		else
		{
			static_assert(false, "Unsupported.");
		}
	}
}

#endif // __disable_mixin_template_library

#pragma optimize("", on) // When you use the on parameter, it resets the optimizations to the ones that you specified using the /O compiler option.